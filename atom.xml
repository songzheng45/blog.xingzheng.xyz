<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just Do It</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.xingzheng.top/"/>
  <updated>2020-05-04T23:56:09.000Z</updated>
  <id>http://blog.xingzheng.top/</id>
  
  <author>
    <name>T羚羊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ABP vNext 切换数据库为 MySQL</title>
    <link href="http://blog.xingzheng.top/2020/05/04/abp-vnext-swithch-to-mysql.html"/>
    <id>http://blog.xingzheng.top/2020/05/04/abp-vnext-swithch-to-mysql.html</id>
    <published>2020-05-04T23:56:09.000Z</published>
    <updated>2020-05-04T23:56:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于启动模板创建的 ABP 项目，默认数据库是 SQLServer，如何切换到 MySQL 呢？下面我来总结一下。</p><a id="more"></a><h2 id="替换包-Volo-Abp-EntityFrameworkCore-SqlServer"><a href="#替换包-Volo-Abp-EntityFrameworkCore-SqlServer" class="headerlink" title="替换包 Volo.Abp.EntityFrameworkCore.SqlServer"></a>替换包 Volo.Abp.EntityFrameworkCore.SqlServer</h2><p>将 <code>.EntityFrameworkCore</code> 引用的 <code>Volo.Abp.EntityFrameworkCore.SqlServer</code> 替换成 <code>Volo.Abp.EntityFrameworkCore.MySQL</code></p><h2 id="替换模块依赖-Module-Dependency"><a href="#替换模块依赖-Module-Dependency" class="headerlink" title="替换模块依赖 (Module Dependency)"></a>替换模块依赖 (Module Dependency)</h2><p>编辑<code>.EntityFrameworkCore</code>项目里的 <code>xxxEntityFrameworkCoreModule.cs</code>类</p><ul><li>将 <code>using Volo.Abp.EntityFrameworkCore.SqlServer;</code>替换为<code>using Volo.Abp.EntityFrameworkCore.MySQL;</code></li><li>将 <code>DependenOn</code>里的<code>typeof(AbpEntityFrameworkCoreMySQLModule)</code>替换为<code>typeof(AbpEntityFrameworkCoreMySQLModule)</code></li></ul><h2 id="UseMySQL"><a href="#UseMySQL" class="headerlink" title="UseMySQL()"></a>UseMySQL()</h2><p>查找解决方案中所有的<code>UseSqlServer()</code>，并替换成<code>UseMySql()</code>.</p><h2 id="修改数据库连接字符串"><a href="#修改数据库连接字符串" class="headerlink" title="修改数据库连接字符串"></a>修改数据库连接字符串</h2><p>找到具有<code>appsetings.json</code>并需要连接数据库的项目，将数据库连接字符串修改为符合 MySQL 格式。 </p><p>可以参考 <a href="https://www.connectionstrings.com/mysql/" target="_blank" rel="noopener">connectionstrings.com</a> 。</p><blockquote><p>通常需要修改<code>.DbMigrator</code>和<code>.Web</code>项目</p></blockquote><h2 id="修改-Migration-DbContext"><a href="#修改-Migration-DbContext" class="headerlink" title="修改 Migration DbContext"></a>修改 Migration DbContext</h2><p><a href="https://docs.abp.io/en/abp/latest/Modules/IdentityServer" target="_blank" rel="noopener">IdentityServer module </a>有自己的数据库映射配置，默认使用 SQLServer 作为数据提供者，需要显式指定成 MySQL。</p><p>在项目<code>.EntityFrameworkCore.DbMigrations</code>里找到 <code>xxxMigrationsDbContext</code>, 修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.ConfigureIdentityServer(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">options.DatabaseProvider &#x3D; EfCoreDatabaseProvider.MySql;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="重新生成迁移"><a href="#重新生成迁移" class="headerlink" title="重新生成迁移"></a>重新生成迁移</h2><ol><li>删除<code>.EntityFrameworkCore.DbMigrations</code>项目下的<code>Migrations</code>文件夹，并重新生成解决方案</li><li>在命令行下切换到<code>.Web</code>项目目录，执行命令类似如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dotnet ef migrations add &#39;InitialCreate&#39; </span><br><span class="line">--project ..&#x2F;LearnAbp.BookStore.EntityFrameworkCore.DbMigrations</span><br></pre></td></tr></table></figure><ol start="3"><li>执行数据库迁移</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dotnet ef database update </span><br><span class="line">--project ..&#x2F;LearnAbp.BookStore.EntityFrameworkCore.DbMigrations</span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>.DbMigrator</code>程序初始种子数据</li></ol><h2 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h2><p>到此数据提供程序就完全切换成 MySQL ，可以启动<code>.Web</code>项目查看效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于启动模板创建的 ABP 项目，默认数据库是 SQLServer，如何切换到 MySQL 呢？下面我来总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ABP" scheme="http://blog.xingzheng.top/tags/ABP/"/>
    
      <category term="MySQL" scheme="http://blog.xingzheng.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第一个 ABP vNext 程序（基于启动模板）</title>
    <link href="http://blog.xingzheng.top/2020/04/28/abp-01-first-application.html"/>
    <id>http://blog.xingzheng.top/2020/04/28/abp-01-first-application.html</id>
    <published>2020-04-28T14:25:23.000Z</published>
    <updated>2020-04-28T14:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://abp.io/" target="_blank" rel="noopener">ABP vNext</a> 是 ASP.NET Boilerplate 的下一代 Web 应用框架（详见博客<a href="https://blog.abp.io/abp/Abp-vNext-Announcement" target="_blank" rel="noopener">Introducing the ABP vNext</a>），它具有完整的架构和强大的基础设施用于快速开发现代化的 Web 应用。遵循最佳实践与惯例可以为你提供一个一致的（SOLID ）开发体验。<br>相关链接:</p><ul><li><a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">GitHub</a></li><li>官方文档： <a href="https://docs.abp.io/en/abp/latest" target="_blank" rel="noopener">英</a> / <a href="https://docs.abp.io/zh-Hans/abp/latest/" target="_blank" rel="noopener">中</a></li></ul><p>新建一个 ABP 应用有两种方式：基于启动模板，或者从空项目开始。本文总结创建基于启动模板的解决方案，并说明每个项目的作用。</p><p>话不多说，我们马上开始创建第一个 ABP vNext 应用吧。</p><a id="more"></a><h2 id="安装-ABP-CLI-命令"><a href="#安装-ABP-CLI-命令" class="headerlink" title="安装 ABP CLI 命令"></a>安装 ABP CLI 命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool install <span class="literal">-g</span> Volo.Abp.Cli</span><br></pre></td></tr></table></figure><p>执行成功后就可以执行 <code>abp new</code> 命令创建指定模板的解决方案。</p><blockquote><p>macOS 下利用 zsh 安装后，可能会提示 <code>zsh: command not found: abp</code>，解决办法如下：</p><p>编辑<code>~/.zshrc</code>，将<code>~/.dotnet/tools</code>添加到PATH 中：</p><p><code>export PATH=$HOME/.dotnet/tools:$PATH</code></p></blockquote><h2 id="解决方案结构"><a href="#解决方案结构" class="headerlink" title="解决方案结构"></a>解决方案结构</h2><h3 id="默认结构"><a href="#默认结构" class="headerlink" title="默认结构"></a>默认结构</h3><p>如果不指定UI 框架，或未指定<code>--tiered</code>选项，则默认创建一个 ASP.NET Core MVC Razor Pages 项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp new LearnAbp.BookStore</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp new LearnAbp.BookStore -u app</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427094447661.png" alt="image-20200427094447661" style="zoom:50%;" /></p><h4 id="项目依赖图"><a href="#项目依赖图" class="headerlink" title="项目依赖图"></a>项目依赖图</h4><p><img src="https://raw.githubusercontent.com/abpframework/abp/master/docs/en/images/layered-project-dependencies.png" alt=""></p><h4 id="Domain-Shared"><a href="#Domain-Shared" class="headerlink" title=".Domain.Shared"></a>.Domain.Shared</h4><p>共享层。</p><p>包含常量、枚举和其它对象，它们是领域层的一部分。</p><p>该项目不引用任何其它项目，但是被所有其它项目直接或间接引用。</p><h4 id="Domain"><a href="#Domain" class="headerlink" title=".Domain"></a>.Domain</h4><p>领域层。</p><p>主要包含实体（entities）、聚合根（aggregate roots）、领域服务（domain services）、值类型（value types）、仓库接口（repositories interfaces）和其它领域对象。</p><h4 id="Application-Contracts"><a href="#Application-Contracts" class="headerlink" title=".Application.Contracts"></a>.Application.Contracts</h4><p>应用契约（接口）层。</p><p>主要包含应用服务（application services）接口和 应用层的DTO（Data Transfer Object）类。</p><p>它存在作用是分离应用层的接口和实现，因此它能作为一个契约包分享给客户端。</p><p>例如： <code>IBookAppService</code>和<code>BookCreationDto</code></p><p>依赖关系：</p><ul><li>依赖<code>.Domain.Shared</code>，因为它可能使用常量、枚举和其它共享对象。</li></ul><h4 id="Application"><a href="#Application" class="headerlink" title=".Application"></a>.Application</h4><p>应用层。</p><p>包含定义在<code>.Application.Contracts</code>中的接口的实现。</p><p>例如：<code>BookAppService</code>实现接口<code>IBookAppService</code>,并依赖<code>.Domain</code>项目来使用实体和领域对象来执行业务逻辑。</p><h4 id="EntityFrameworkCore"><a href="#EntityFrameworkCore" class="headerlink" title=".EntityFrameworkCore"></a>.EntityFrameworkCore</h4><p>集成 EF Core。</p><p>定义 <code>DbContext</code> 并实现定义在 <code>.Domain</code> 中的仓库接口。</p><p>只有当使用 EF Core 作为数据提供者的时候，该项目才有用。如果数据源用的是 MongoDB、Dapper 等等，该项目的名字和实现也会不同。</p><h4 id="EntityFrameworkCore-DbMigrations"><a href="#EntityFrameworkCore-DbMigrations" class="headerlink" title=".EntityFrameworkCore.DbMigrations"></a>.EntityFrameworkCore.DbMigrations</h4><p>EF Core 数据库迁移层。</p><p>它有一个单独的<code>DbContext</code>专门用于管理迁移。</p><p>ABP 是一个具有理想设计的模块化框架，每个模块（module）有它自己的<code>DbContext</code>类。基于此，用于迁移的<code>DbContext</code>把所有<code>DbContext</code>配置整合到一个单独的 model 里来维护同一个数据库结构。</p><p>在高级场景中，我们可以有多个数据库和多个迁移<code>DbContext</code>类。</p><blockquote><p>注意：</p><p>迁移<code>DbContext</code>仅用作数据库迁移，而不会在程序运行时调用。</p></blockquote><p>依赖关系：</p><ul><li>依赖<code>.EntityFrameworkCore</code>，因为它重用应用程序里为<code>DbContext</code>定义的通用配置。</li></ul><h4 id="DbMigrator"><a href="#DbMigrator" class="headerlink" title=".DbMigrator"></a>.DbMigrator</h4><p>控制台程序，用来简化在开发和生产环境的数据库迁移。</p><p>它做了以下几件事：</p><ul><li>在必要时创建数据库</li><li>应用还未生效的迁移更改</li><li>需要时填充种子数据</li></ul><p>特别地，填充种子数据在这里很重要。ABP 框架具有模块化的架构去填充种子数据，详细可以<a href="https://docs.abp.io/en/abp/latest/Data-Seeding" target="_blank" rel="noopener">查看文档</a>。</p><p>该程序不仅可用于关系型数据库，也可用于为 NoSQL 数据库填充种子数据。</p><p>依赖关系：</p><ul><li><p>依赖<code>.EntityFrameworkCore.DbMigrations</code>并访问定义其中的迁移</p></li><li><p>依赖<code>.Application.Contracts</code>因此可以访问权限定义，默认授权 <em>admin</em> 所有权限</p></li></ul><h4 id="HttpApi"><a href="#HttpApi" class="headerlink" title=".HttpApi"></a>.HttpApi</h4><p>自定义 API Controller。</p><p>大多时候我们不需要定义API Controller，因为 ABP 框架 <a href="https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers" target="_blank" rel="noopener">Auto API Controller</a>特性会基于应用程序分层自动创建它们。</p><p>依赖关系：</p><ul><li>依赖<code>.Application.Contracts</code>以注入应用服务接口。</li></ul><h4 id="HttpApi-Client"><a href="#HttpApi-Client" class="headerlink" title=".HttpApi.Client"></a>.HttpApi.Client</h4><p>C#客户端代理，用来访问解决方案里的 HTTP API，并可以分享给第三方客户，为他们访问 HTTP API 提供方便。</p><p>由于<a href="https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients" target="_blank" rel="noopener">Dynamic C# API Clients</a>，大多时候我们无需手动创建C#客户端代理。</p><blockquote><p><code>.HttpApi.Client.ConsoleTestApp</code>项目演示如何使用这个客户端代理。</p></blockquote><p>依赖关系：</p><ul><li>依赖<code>.Application.Contracts</code>以共享远程服务使用的接口和 DTO 类。</li></ul><blockquote><p>不需要的话可以删掉该项目。</p></blockquote><h4 id="Web"><a href="#Web" class="headerlink" title=".Web"></a>.Web</h4><p>该项目是 ASP.NET Core MVC UI 层，包含Razor Pages，JavaScript 文件，CSS 文件等等。</p><p>该项目包含主要的<code>appsettings.json</code>文件，包含数据库连接字符串以及其它程序配置项。</p><p>依赖关系：</p><ul><li>依赖<code>.HttpApi</code>，因为UI 层需要使用 API和应用程序接口。</li></ul><blockquote><p>该项目引用了<code>.Application</code>和<code>.EntityFrameworkCore.DbMigrations</code>两个项目，而实际上这两个引用在 UI 层是不需要的，因为 UI 通常并不依赖于 EF Core 和 Application 层的实现。</p><p>这是由于创建解决方案时没有指定<code>--tiered</code>选项，因此<code>.Web</code>项目在单个服务里托管 UI，API和应用层。</p><p>总的来说，这种结构不符合 DDD 最佳实践，应该在展示层可以直接使用Domain Entity和仓储。</p></blockquote><p>接下来看分层结构。</p><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp new LearnAbp.BookStore --tiered</span><br></pre></td></tr></table></figure><p>创建的解决方案如下图：</p><p><img src="/images/image-20200427185518992.png" alt="image-20200427185518992" style="zoom:50%;" /></p><p>指定<code>--tiered</code>选项创建的是一个前后端分离的解决方案，并且多出两个项目<code>.IdentityServer</code>和<code>.HttpApi.Host</code>。</p><h4 id="IdentityServer"><a href="#IdentityServer" class="headerlink" title=".IdentityServer"></a>.IdentityServer</h4><p>作为认证服务器被其它项目使用。</p><p><code>.Web</code>项目通过 <em>OpenId Connect Authentication</em> 从 IdentityServer 为当前用户获取 ID 和 access token，然后使用access token 去调用 HTTP API 服务。HTTP API 服务使用 bearer token 认证方式从 access token 中提取声明以授权当前用户。</p><p><img src="https://raw.githubusercontent.com/abpframework/abp/master/docs/en/images/tiered-solution-applications.png" alt=""></p><p>ABP 使用开源的 <a href="https://identityserver.io/" target="_blank" rel="noopener">IdentityServer4</a> 框架在应用程序之间做认证，具体看<a href="http://docs.identityserver.io/" target="_blank" rel="noopener">IdentityServer4 文档</a> 了解IdentityServer4 和 OpenID Connect 协议。</p><h4 id="HttpApi-Host"><a href="#HttpApi-Host" class="headerlink" title=".HttpApi.Host"></a>.HttpApi.Host</h4><p>托管 HTTP API。</p><p>它有自己的<code>appsettings.json</code>来存放数据库连接和其它配置。</p><h4 id="Web-1"><a href="#Web-1" class="headerlink" title=".Web"></a>.Web</h4><p>托管 UI，和默认结构里的一样。</p><p>不过这个<code>.Web</code>的<code>appsettings.json</code>不再需要连接数据库的配置，而是存放远程 API 和认证服务的地址。</p><h4 id="如何运行？"><a href="#如何运行？" class="headerlink" title="如何运行？"></a>如何运行？</h4><ol><li>启动 <code>.IdentityServer</code>，因为其他程序依赖它</li><li>启动 <code>.HttpApi.Host</code> ，因为它被<code>.Web</code>调用</li><li>启动 <code>.Web</code> 并登入系统</li></ol><h3 id="Angular-UI"><a href="#Angular-UI" class="headerlink" title="Angular UI"></a>Angular UI</h3><p>如果选择 <code>Angular</code> 作为 UI 框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp new LearnAbp.BookStore -u angular</span><br></pre></td></tr></table></figure><p>解决方案会被分成三个文件夹：</p><ul><li><code>angular</code> 包含 Angular UI 程序，作为前端代码</li><li><code>aspnet-core</code> 包含 ASP.NET Core 解决方案，作为服务的代码</li><li><code>react-native</code> 包含 React Native UI 程序，作为移动端的前端代码</li></ul><p>服务端代码和上面介绍的类似，不过不再有<code>.Web</code>项目。<code>*.HttpApi.Host</code>项目托管 HTTP API， <code>Angular</code>调用它。</p><p>项目结构详细说明，可参考官方文档： <a href="https://docs.abp.io/en/abp/latest/Startup-Templates/Application#angular-ui" target="_blank" rel="noopener">Angular UI</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://abp.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ABP vNext&lt;/a&gt; 是 ASP.NET Boilerplate 的下一代 Web 应用框架（详见博客&lt;a href=&quot;https://blog.abp.io/abp/Abp-vNext-Announcement&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing the ABP vNext&lt;/a&gt;），它具有完整的架构和强大的基础设施用于快速开发现代化的 Web 应用。遵循最佳实践与惯例可以为你提供一个一致的（SOLID ）开发体验。&lt;br&gt;相关链接:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/abpframework/abp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方文档： &lt;a href=&quot;https://docs.abp.io/en/abp/latest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;英&lt;/a&gt; / &lt;a href=&quot;https://docs.abp.io/zh-Hans/abp/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新建一个 ABP 应用有两种方式：基于启动模板，或者从空项目开始。本文总结创建基于启动模板的解决方案，并说明每个项目的作用。&lt;/p&gt;
&lt;p&gt;话不多说，我们马上开始创建第一个 ABP vNext 应用吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="abp" scheme="http://blog.xingzheng.top/tags/abp/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Next 集成站内搜索 Algolia</title>
    <link href="http://blog.xingzheng.top/2018/10/29/hexo-next-integrated-algolia.html"/>
    <id>http://blog.xingzheng.top/2018/10/29/hexo-next-integrated-algolia.html</id>
    <published>2018-10-29T13:02:13.000Z</published>
    <updated>2018-10-29T13:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册algolia"><a href="#注册algolia" class="headerlink" title="注册algolia"></a>注册algolia</h2><p>打开<a href="https://www.algolia.com/users/sign_up" target="_blank" rel="noopener">注册页面</a>，选择使用邮箱或者使用Github、Google帐户创建一个帐号。  </p><p>登录进去后，默认进入<code>Dashboard</code>页面。点击左侧菜单的<code>Indices</code>，再点击右上角的<code>New Index</code>，创建新索引。</p><a id="more"></a><h2 id="配置并安装algolia"><a href="#配置并安装algolia" class="headerlink" title="配置并安装algolia"></a>配置并安装algolia</h2><p>编辑站点配置<code>_config.yml</code></p><h2 id="配置Next主题"><a href="#配置Next主题" class="headerlink" title="配置Next主题"></a>配置Next主题</h2><p>在 <code>themes/next/_config.yml</code> 文件, 找到 <code>algolia_search</code>节点, 如下:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">输入搜索关键词</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"找不到任何搜索结果: $&#123;query&#125;"</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"找到 $&#123;hits&#125; 个搜索结果, 耗时: $&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure><br><code>enable</code>设为true, <code>per_page</code>每页多少个搜索结果, 其它根据需要修改.</p><h2 id="解决遇到的问题"><a href="#解决遇到的问题" class="headerlink" title="解决遇到的问题"></a>解决遇到的问题</h2><h3 id="Travis-构建时报错-Cannot-find-module-‘bluebird’"><a href="#Travis-构建时报错-Cannot-find-module-‘bluebird’" class="headerlink" title="Travis 构建时报错 : Cannot find module ‘bluebird’"></a>Travis 构建时报错 : Cannot find module ‘bluebird’</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">ERROR Plugin load failed: hexo-algolia</span><br><span class="line">Error: Cannot find module <span class="string">'bluebird'</span></span><br></pre></td></tr></table></figure><p>安装 bluebird 即可解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save bluebird</span><br></pre></td></tr></table></figure></p><h3 id="Travis-构建时报错-AlgoliaSearchError-Operations-quota-exceeded"><a href="#Travis-构建时报错-AlgoliaSearchError-Operations-quota-exceeded" class="headerlink" title="Travis 构建时报错 : AlgoliaSearchError: Operations quota exceeded"></a>Travis 构建时报错 : AlgoliaSearchError: Operations quota exceeded</h3><p>使用 Travis 构建时报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/home/travis/build/xxxx/node_modules/hexo-algolia/lib/command.js:85</span><br><span class="line"></span><br><span class="line">      throw err;</span><br><span class="line"></span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">AlgoliaSearchError: Operations quota exceeded, change plan to get more Operations.</span><br><span class="line"></span><br><span class="line">    at success (/home/travis/build/songzheng45/xingzheng.me/node_modules/hexo-algolia/node_modules/algoliasearch/src/AlgoliaSearchCore.js:335:32)</span><br><span class="line"></span><br><span class="line">    at process._tickCallback (node.js:369:9)</span><br></pre></td></tr></table></figure><br>打开<a href="https://www.algolia.com/" target="_blank" rel="noopener">Algolia官网</a>，登录进入Dashboard，发现 Algolia 改版了，必须选择一个付费计划，选择<code>Go Free</code>。<br>回到 Travis 再次构建成功。</p><h3 id="Travis-构建时报错-需要设置-Algolia-INDEXING-KEY"><a href="#Travis-构建时报错-需要设置-Algolia-INDEXING-KEY" class="headerlink" title="Travis 构建时报错: 需要设置 Algolia INDEXING_KEY"></a>Travis 构建时报错: 需要设置 Algolia INDEXING_KEY</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR [Algolia] Please <span class="built_in">set</span> an `HEXO_ALGOLIA_INDEXING_KEY` environment variable to <span class="built_in">enable</span> content indexing</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>在 Travis 项目下，依次打开 <code>More Options</code>-<code>Settings</code>，在 <code>Environment Variables</code> 下添加一项键值对：</p><table><thead><tr><th style="text-align:center">HEXO_ALGOLIA_INDEXING_KEY</th><th style="text-align:center">Algolia API KEY</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>其中 <code>Algolia API KEY</code>填写 Alogolia 网站上生成的 <code>Search-Only API Key</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注册algolia&quot;&gt;&lt;a href=&quot;#注册algolia&quot; class=&quot;headerlink&quot; title=&quot;注册algolia&quot;&gt;&lt;/a&gt;注册algolia&lt;/h2&gt;&lt;p&gt;打开&lt;a href=&quot;https://www.algolia.com/users/sign_up&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;注册页面&lt;/a&gt;，选择使用邮箱或者使用Github、Google帐户创建一个帐号。  &lt;/p&gt;
&lt;p&gt;登录进去后，默认进入&lt;code&gt;Dashboard&lt;/code&gt;页面。点击左侧菜单的&lt;code&gt;Indices&lt;/code&gt;，再点击右上角的&lt;code&gt;New Index&lt;/code&gt;，创建新索引。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://blog.xingzheng.top/tags/Hexo/"/>
    
      <category term="Next" scheme="http://blog.xingzheng.top/tags/Next/"/>
    
      <category term="Algolia" scheme="http://blog.xingzheng.top/tags/Algolia/"/>
    
  </entry>
  
  <entry>
    <title>install-vsftpd-on-ubuntu</title>
    <link href="http://blog.xingzheng.top/2018/10/27/install-vsftpd-on-ubuntu.html"/>
    <id>http://blog.xingzheng.top/2018/10/27/install-vsftpd-on-ubuntu.html</id>
    <published>2018-10-27T20:14:06.000Z</published>
    <updated>2018-10-27T20:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><p>安装程序会给本地创建一个名为“ftp”的用户组，命令执行完之后会自动启动FTP服务。</p><h2 id="检查FTP服务是否启动"><a href="#检查FTP服务是否启动" class="headerlink" title="检查FTP服务是否启动"></a>检查FTP服务是否启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntl</span><br></pre></td></tr></table></figure><p>查看是否打开21端口，输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -npltu | grep 21</span><br><span class="line">tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      15601&#x2F;vsftpd</span><br></pre></td></tr></table></figure></p><h2 id="开启、停止、重启vsftpd服务的命令："><a href="#开启、停止、重启vsftpd服务的命令：" class="headerlink" title="开启、停止、重启vsftpd服务的命令："></a>开启、停止、重启vsftpd服务的命令：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service vsftpd start | stop | restart</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="准备FTP登录用户"><a href="#准备FTP登录用户" class="headerlink" title="准备FTP登录用户"></a>准备FTP登录用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd vsftpd -s &#x2F;sbin&#x2F;nologin -m ftpuser</span><br></pre></td></tr></table></figure><ul><li>ftpuser：将要创建的ftp用户名</li><li>-s：指定shell，参数是：/sbin/nologin，意思是创建的ftpuser无法从系统登录</li><li>-m：创建该用户的家目录（/home/ftpuser）</li></ul><h2 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;vsftpd.conf</span><br></pre></td></tr></table></figure><p>主要做以下修改：</p><blockquote><p>anonymous_enable=NO<br>local_enable=YES<br>write_enable=YES<br>local_root=/var/www     （/var/www 是ftp用户登录后进入的根目录，不能再切换到其他目录）</p></blockquote><h2 id="修改目录权限（如果没有就创建）"><a href="#修改目录权限（如果没有就创建）" class="headerlink" title="修改目录权限（如果没有就创建）"></a>修改目录权限（如果没有就创建）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;www</span><br><span class="line">chmod 777 &#x2F;var&#x2F;www</span><br></pre></td></tr></table></figure><h2 id="重启vsftpd"><a href="#重启vsftpd" class="headerlink" title="重启vsftpd"></a>重启vsftpd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service vsftpd restart</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge vsftpd</span><br></pre></td></tr></table></figure><h3 id="xftp连接vsftpd的一些问题"><a href="#xftp连接vsftpd的一些问题" class="headerlink" title="xftp连接vsftpd的一些问题"></a>xftp连接vsftpd的一些问题</h3><ol><li><p>传文件的根目录是“/var/www”，使用本地用户sxz登录到ftp， 提示：“553 could not create file”<br><strong>原因</strong>：用户sxz对/var/www没有权限。<br>可以看到，/var/www 文件夹的所有者和群组是 <code>root:root</code>，因此用户sxz没有权限。<br>执行命令：  <code>sxz@ubuntuserver2:~$ sudo chown -R sxz:sxz /var/www</code><br>将目录“/var/www”所有者和群组修改为用户sxz。<br>重试上传，成功。</p></li><li><p>OOPS: vsftpd: refusing to run with writable root inside chroot()<br><a href="http://www.liquidweb.com/kb/error-500-oops-vsftpd-refusing-to-run-with-writable-root-inside-chroot-solved/" target="_blank" rel="noopener">http://www.liquidweb.com/kb/error-500-oops-vsftpd-refusing-to-run-with-writable-root-inside-chroot-solved/</a><br><strong>解决</strong>：<br><code>sxz@ubuntuserver2:/$ sudo nano /etc/vsftpd.conf</code><br>添加一句：<code>allow_writable_root=YES</code></p></li></ol><blockquote><p><strong>附录</strong>：vsftpd配置解析<br>/etc/vsftpd.conf</p><ul><li>chroot：即change root directory （改变根目录），使用chroot后，系统的根目录将以指定的位置作为“/”位置。</li><li>chroot_local_user=YES<br>将所有本地用户限制在自家目录中，NO则不限制。下面的指令是指出在所有本地用户中例外于本指令规定的用户。</li><li>local_umask=022<br>掩码，默认是777.<br><a href="http://bbs.chinaunix.net/thread-669631-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-669631-1-1.html</a></li><li>local_root=/var/www<br>登录ftp后的根目录</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install vsftpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装程序会给本地创建一个名为“ftp”的用户组，命令执行完之后会自动启动FTP服务。&lt;/p&gt;
&lt;h2 id=&quot;检查FTP服务是否启动&quot;&gt;&lt;a href=&quot;#检查FTP服务是否启动&quot; class=&quot;headerlink&quot; title=&quot;检查FTP服务是否启动&quot;&gt;&lt;/a&gt;检查FTP服务是否启动&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat -ntl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看是否打开21端口，输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo netstat -npltu | grep 21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      15601&amp;#x2F;vsftpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;开启、停止、重启vsftpd服务的命令：&quot;&gt;&lt;a href=&quot;#开启、停止、重启vsftpd服务的命令：&quot; class=&quot;headerlink&quot; title=&quot;开启、停止、重启vsftpd服务的命令：&quot;&gt;&lt;/a&gt;开启、停止、重启vsftpd服务的命令：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service vsftpd start | stop | restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Ubuntu" scheme="http://blog.xingzheng.top/tags/Ubuntu/"/>
    
      <category term="ftp" scheme="http://blog.xingzheng.top/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下安装、卸载 .NET Core</title>
    <link href="http://blog.xingzheng.top/2018/07/09/dotnetcore-install-uninstall-on-linux.html"/>
    <id>http://blog.xingzheng.top/2018/07/09/dotnetcore-install-uninstall-on-linux.html</id>
    <published>2018-07-09T18:48:41.000Z</published>
    <updated>2018-07-09T18:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>.NET Core <a href="https://www.microsoft.com/net/core#linuxubuntu" target="_blank" rel="noopener">Get Started with .NET Core</a></p><p>最新版本的 SDK 和 Runtime 前往<a href="https://www.microsoft.com/net/download/core#/runtime" target="_blank" rel="noopener">.NET Core下载页面</a></p><h2 id="仅安装Runtime"><a href="#仅安装Runtime" class="headerlink" title="仅安装Runtime"></a>仅安装Runtime</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dotnet-sharedframework-microsoft.netcore.app-&lt;version&gt;</span><br></pre></td></tr></table></figure><p>查看可用版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt search dotnet-sharedframework-microsoft.netcore.app</span><br></pre></td></tr></table></figure><br>如安装 Runtime 1.1.2：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dotnet-sharedframework-microsoft.netcore.app-1.1.2</span><br></pre></td></tr></table></figure></p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ol><li>使用sh脚本卸载<br><a href="https://github.com/dotnet/cli/blob/rel/1.0.0/scripts/obtain/uninstall/dotnet-uninstall-debian-packages.sh" target="_blank" rel="noopener">点击这里</a> 下载卸载脚本，在 Ubuntu 下运行即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;.NET Core &lt;a href=&quot;https://www.microsoft.com/net/core#linuxubuntu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Get Started with .NET Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最
      
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term=".NET Core" scheme="http://blog.xingzheng.top/tags/NET-Core/"/>
    
      <category term="Ubuntu" scheme="http://blog.xingzheng.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains 激活</title>
    <link href="http://blog.xingzheng.top/2018/07/09/jetbrains-activation.html"/>
    <id>http://blog.xingzheng.top/2018/07/09/jetbrains-activation.html</id>
    <published>2018-07-09T18:44:43.000Z</published>
    <updated>2018-07-09T18:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>尝试使用 <a href="https://idea.sunleon.top/" target="_blank" rel="noopener">夏季笔录</a> 提供的现成License Server： <code>https://idea.sunleon.top</code> 亲测有效</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尝试使用 &lt;a href=&quot;https://idea.sunleon.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;夏季笔录&lt;/a&gt; 提供的现成License Server： &lt;code&gt;https://idea.sunleon.top&lt;/code&gt; 亲测有效&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JetBrains激活" scheme="http://blog.xingzheng.top/tags/JetBrains%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET MVC 启用 CORS</title>
    <link href="http://blog.xingzheng.top/2017/09/27/asp-net-mvc-how-to-enable-cors.html"/>
    <id>http://blog.xingzheng.top/2017/09/27/asp-net-mvc-how-to-enable-cors.html</id>
    <published>2017-09-27T17:24:15.000Z</published>
    <updated>2017-09-27T17:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器出于安全性考虑, 会阻止 AJAX 请求其他域名下的资源. 这个限制叫作 <code>same-origin</code>(同源) 策略.  </p><h2 id="什么是同源"><a href="#什么是同源" class="headerlink" title="什么是同源?"></a>什么是同源?</h2><p>如果两个 URL 有相同的scheme、域名和端口, 他们就有相同的来源.</p><p>以下两个 URL 是同源的:</p><ul><li><code>http://example.com/foo.html</code></li><li><code>http://example.com/bar.html</code></li></ul><p>以下这些 URL 相比上面两个是非同源的:</p><ul><li><code>http://example.net</code>, 不同的域名</li><li><code>http://www.example.com/foo.html</code>, 不同的子域名</li><li><code>https://example.com/foo.html</code>, 不同的 scheme</li><li><code>http://example.com:9000/foo.html</code>, 不同的端口</li></ul><p>例如, 在 <code>www.xingzheng.me/books</code> 页面上通过 AJAX 访问 <code>www.xingzheng.me/api/blogs</code> 是没问题的. 但是访问 <code>api.xingzheng.me/blogs</code> 就会失败, 浏览器控制台会输出如下错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:&#x2F;&#x2F;api.xingzheng.me&#x2F;blogs. </span><br><span class="line">No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. </span><br><span class="line">Origin &#39;http:&#x2F;&#x2F;www.xingzheng.me&#39; is therefore not allowed access.</span><br></pre></td></tr></table></figure></p><blockquote><p>同源策略不会阻止浏览器发送请求, 但是会阻止应用程序”看到”响应内容.<br>同源策略能够阻止恶意网站读取其他网站的敏感数据.  </p></blockquote><a id="more"></a><h2 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h2><p><a href="http://www.w3.org/TR/cors/" target="_blank" rel="noopener">Cross Origin Resource Sharing</a>(CORS) 是一个 w3c 标准, 允许服务器放宽 <code>same-origin</code> 策略. 使用 CORS , 服务器可以在允许一些”跨源”的请求的同时拒绝其他的请求. CORS 比早期的技术如 JSONP 更安全、更灵活.</p><h2 id="CORS-是如何工作的"><a href="#CORS-是如何工作的" class="headerlink" title="CORS 是如何工作的?"></a>CORS 是如何工作的?</h2><p>CORS 规范介绍了几个新的 HTTP 头来允许 <code>cross-origin</code> 请求. 如果浏览器支持 CORS , 它会自动设置这些 HTTP 头, 我们在 Javascrpit 代码中什么都不用做.</p><p>例如, 以下是一个跨域请求的请求头信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.caiwu.com&#x2F;message.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.caiwu.com</span><br><span class="line">Origin: http:&#x2F;&#x2F;m.caiwu.com</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Referer: http:&#x2F;&#x2F;m.caiwu.com&#x2F;index.html</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,en;q&#x3D;0.6,zh-TW;q&#x3D;0.4,en-US;q&#x3D;0.2</span><br></pre></td></tr></table></figure><br><code>Origin</code> 的值就是发出请求的域名.</p><p>服务器如果允许本次请求, 则在响应头中设置 <code>Access-Control-Allow-Origin</code>, 值就是上面 <code>Origin</code> 的值(如果是 <code>*</code> 表示允许来自所有 <code>origin</code> 的请求, 有很大安全隐患).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;m.caiwu.com</span><br><span class="line">Date: Wed, 27 Sep 2017 02:47:18 GMT</span><br></pre></td></tr></table></figure><br>如果响应头中不包含 <code>Access-Control-Allow-Origin</code>, 表示服务器不允许跨域请求, 则请求失败, 浏览器会明确指出不允许该请求. 即使服务器返回成功(200), 浏览器也不会让客户端看到响应内容.  </p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>对一些 CORS 请求,在向资源发出真正的请求之前, 浏览器会发送一个额外请求, 叫作”预检请求”.</p><p>先看个例子, 以下是预检请求的请求头:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS http:&#x2F;&#x2F;myservice.azurewebsites.net&#x2F;api&#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Origin: http:&#x2F;&#x2F;myclient.azurewebsites.net</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: accept, x-my-custom-header</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident&#x2F;6.0)</span><br><span class="line">Host: myservice.azurewebsites.net</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure></p><p>预检请求使用 HTTP OPTIONS 方法, 它包含两个特殊的请求头: </p><ul><li>Access-Control-Request-Method<br>  后续实际请求中使用的 HTTP 方法.</li><li>Access-Control-Request-Headers<br>  一个请求头列表, 包含服务端应用程序在实际请求中设置的(不包含浏览器设置的头).</li></ul><p>预检请求的响应头, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Length: 0</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;myclient.azurewebsites.net</span><br><span class="line">Access-Control-Allow-Headers: x-my-custom-header</span><br><span class="line">Access-Control-Allow-Methods: PUT</span><br><span class="line">Date: Wed, 05 Jun 2013 06:33:22 GMT</span><br></pre></td></tr></table></figure><br>响应包含的 <code>Access-Control-Allow-Methods</code> 列出允许的方法, 和一个可选的 <code>Access-Control-Allow-Headers</code> 头, 列出允许的头.<br>如果预检请求成功, 浏览器会发送实际的请求.</p><h2 id="ASP-NET-MVC5-启用-CORS"><a href="#ASP-NET-MVC5-启用-CORS" class="headerlink" title="ASP.NET MVC5 启用 CORS"></a>ASP.NET MVC5 启用 CORS</h2><p>在 ASP.NET MVC5 中支持 CORS 有三种方式:</p><ul><li>自定义 ActionFilterAttribute</li><li>Web.config 配置 <code>httpProtocol/customHeaders</code></li></ul><h3 id="自定义-ActionFilterAttribute"><a href="#自定义-ActionFilterAttribute" class="headerlink" title="自定义 ActionFilterAttribute"></a>自定义 ActionFilterAttribute</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AllowCORSAttribute : ActionFilterAttribute</span><br><span class="line">&#123;</span><br><span class="line">    public override void OnActionExecuting(ActionExecutingContext filterContext)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 支持多个域名的跨域请求</span><br><span class="line">        List&lt;string&gt; domains &#x3D; new List&lt;string&gt;() &#123; &quot;http:&#x2F;&#x2F;domain1.com&quot;, &quot;http:&#x2F;&#x2F;domain2.com&quot; &#125;;</span><br><span class="line">        var host &#x3D; filterContext.HttpContext.Request.UrlReferrer.Host;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        var filterHost &#x3D; domains.FirstOrDefault(x &#x3D;&gt; x.Contains(host));</span><br><span class="line">        if (filterHost !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 允许跨域请求的域名</span><br><span class="line">            filterContext.HttpContext.Response.Headers.Add(&quot;Access-Control-Allow-Origin&quot;, filterHost);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果请求要传递cookie或其他认证方案所需的信息, 需要设置 Access-Control-Allow-Credentials 为 true</span><br><span class="line">            filterContext.HttpContext.Response.Headers.Add(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base.OnActionExecuting(filterContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将该过滤器应用到 Action、Controller 或者全局。</p><h3 id="Web-config-配置-httpProtocol-customHeaders"><a href="#Web-config-配置-httpProtocol-customHeaders" class="headerlink" title="Web.config 配置 httpProtocol/customHeaders"></a>Web.config 配置 <code>httpProtocol/customHeaders</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">httpProtocol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">customHeaders</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">clear</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"Access-Control-Allow-Origin"</span> <span class="attr">value</span>=<span class="string">"http://domain1.com"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"Access-Control-Allow-Credentials"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">customHeaders</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">httpProtocol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="ASP-NET-WebAPI-2-启用-CORS"><a href="#ASP-NET-WebAPI-2-启用-CORS" class="headerlink" title="ASP.NET WebAPI 2 启用 CORS"></a>ASP.NET WebAPI 2 启用 CORS</h3><p><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api" target="_blank" rel="noopener">Enabling Cross-Origin Requests in ASP.NET Web API 2</a></p><h3 id="ASP-NET-Core-启用-CORS"><a href="#ASP-NET-Core-启用-CORS" class="headerlink" title="ASP.NET Core 启用 CORS"></a>ASP.NET Core 启用 CORS</h3><p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors" target="_blank" rel="noopener">Enabling Cross-Origin Requests (CORS)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器出于安全性考虑, 会阻止 AJAX 请求其他域名下的资源. 这个限制叫作 &lt;code&gt;same-origin&lt;/code&gt;(同源) 策略.  &lt;/p&gt;
&lt;h2 id=&quot;什么是同源&quot;&gt;&lt;a href=&quot;#什么是同源&quot; class=&quot;headerlink&quot; title=&quot;什么是同源?&quot;&gt;&lt;/a&gt;什么是同源?&lt;/h2&gt;&lt;p&gt;如果两个 URL 有相同的scheme、域名和端口, 他们就有相同的来源.&lt;/p&gt;
&lt;p&gt;以下两个 URL 是同源的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://example.com/foo.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com/bar.html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下这些 URL 相比上面两个是非同源的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://example.net&lt;/code&gt;, 不同的域名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://www.example.com/foo.html&lt;/code&gt;, 不同的子域名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https://example.com/foo.html&lt;/code&gt;, 不同的 scheme&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com:9000/foo.html&lt;/code&gt;, 不同的端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如, 在 &lt;code&gt;www.xingzheng.me/books&lt;/code&gt; 页面上通过 AJAX 访问 &lt;code&gt;www.xingzheng.me/api/blogs&lt;/code&gt; 是没问题的. 但是访问 &lt;code&gt;api.xingzheng.me/blogs&lt;/code&gt; 就会失败, 浏览器控制台会输出如下错误:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XMLHttpRequest cannot load http:&amp;#x2F;&amp;#x2F;api.xingzheng.me&amp;#x2F;blogs. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Origin &amp;#39;http:&amp;#x2F;&amp;#x2F;www.xingzheng.me&amp;#39; is therefore not allowed access.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同源策略不会阻止浏览器发送请求, 但是会阻止应用程序”看到”响应内容.&lt;br&gt;同源策略能够阻止恶意网站读取其他网站的敏感数据.  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ASP.NET MVC" scheme="http://blog.xingzheng.top/tags/ASP-NET-MVC/"/>
    
      <category term="CORS" scheme="http://blog.xingzheng.top/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor入门</title>
    <link href="http://blog.xingzheng.top/2017/06/21/learn-supervisor.html"/>
    <id>http://blog.xingzheng.top/2017/06/21/learn-supervisor.html</id>
    <published>2017-06-21T09:32:02.000Z</published>
    <updated>2017-06-21T09:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Supervisor"><a href="#关于-Supervisor" class="headerlink" title="关于 Supervisor"></a>关于 Supervisor</h2><p>Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p><p>supervisor 是一个 C/S 模型的程序，由 server 和 client 模块组成：</p><ol><li>supervisord</li><li>supervisorctl<br>supervisorctl 是命令行工具，我们通过它可以在终端操作 supervisord ，例如启动、停止任务，详细的命令可使用<code>supervisorctl -h</code> 查看。</li></ol><p>官方文档：<a href="http://supervisord.org/" target="_blank" rel="noopener">http://supervisord.org/</a></p><a id="more"></a><h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><ol><li>macOS 下使用 Homebrew安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install supervisor</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu 使用 apt 或 apt-get</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt install supervisor</span><br></pre></td></tr></table></figure></li><li><p>pip安装<br>supervisor 是用 Python 写的，所以可以使用pip（据说不支持Python3，但是有Python3的移植版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install supervisor</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="重定向配置文件"><a href="#重定向配置文件" class="headerlink" title="重定向配置文件"></a>重定向配置文件</h3><p>安装完 supervisor 之后，可以运行 <code>echo_supervisord_conf</code> 命令输出默认的配置项，一般会将配置项重定向到一个配置文件里。使用以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><br>如果提示 <code>Permission Denied</code>，则使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su root -c &quot;echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf&quot;</span><br></pre></td></tr></table></figure></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>对配置文件做以下改动，并取消注释[include]：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/var/run/supervisor.sock   <span class="comment">; (the path to the socket file)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/var/log/supervisor/supervisord.log <span class="comment">; (main log file;default $CWD/supervisord.log)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///var/run/supervisor.sock <span class="comment">; use a unix:// URL  for a unix socket</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/conf.d/*.ini</span><br></pre></td></tr></table></figure><br><strong>注意</strong>： <code>unix_http_server</code> 跟 <code>supervisorctl</code> 中的 sock 文件路径要一致<br><code>[include]</code>  项表示包含指定目录下所有<code>*.ini</code>  作为脚本，我们可以为每个任务创建一个ini文件，以方便管理。<br>如果这时目录 <code>conf.d</code> 还不存在，我们要先创建该目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/supervisor/conf.d</span><br></pre></td></tr></table></figure><br>之后管理任务的脚本放到 <code>conf.d</code> 就行了。</p><h3 id="编写任务脚本"><a href="#编写任务脚本" class="headerlink" title="编写任务脚本"></a>编写任务脚本</h3><p>netcorejob.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:netcorejob]</span><br><span class="line">command&#x3D;dotnet   NETCore.dll</span><br><span class="line">directroy&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;netcore&#x2F;</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line">startretries&#x3D;3</span><br><span class="line">user&#x3D;ubuntu</span><br><span class="line">stdout_logfile&#x3D;&#x2F;log&#x2F;supervisor&#x2F;netcore.out.log</span><br><span class="line">stderr_logfile&#x3D;&#x2F;log&#x2F;supervisor&#x2F;netcore.err.log</span><br></pre></td></tr></table></figure></p><h3 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl start netcorejob</span><br><span class="line">netcorejob: started</span><br></pre></td></tr></table></figure><h3 id="停止任务"><a href="#停止任务" class="headerlink" title="停止任务"></a>停止任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl stop netcorejob</span><br><span class="line">netcorejob: stopped</span><br></pre></td></tr></table></figure><h3 id="查看任务状态"><a href="#查看任务状态" class="headerlink" title="查看任务状态"></a>查看任务状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl</span><br><span class="line">netcorejob                       RUNNING   pid 24330, uptime 0:04:37</span><br></pre></td></tr></table></figure><h3 id="重启和重载"><a href="#重启和重载" class="headerlink" title="重启和重载"></a>重启和重载</h3><p><a href="http://www.onurguzel.com/supervisord-restarting-and-reloading/" target="_blank" rel="noopener">Supervisord: Restarting and Reloading</a></p><ul><li><p><code>service supervisor restart</code><br>重启 supervisor 服务，它会停止、然后再启动所以管理的程序。<br>使用该命令，不会应用修改后的配置。</p></li><li><p><code>supervisorctl restart &lt;name&gt;</code><br>重启程序，且不会应用修改后的配置。</p></li></ul><p>如果你创建了新的配置，以上命令都不会使它们可用。如果要在现有的和新的配置中应用更改、启动新的应用程序，并且重启所有管理的应用程序，你应该运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service supervisor stop</span><br><span class="line">service supervisor start</span><br></pre></td></tr></table></figure></p><p>如果你不想重启所有管理的程序，但是想使修改的配置生效，运行这个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reread</span><br></pre></td></tr></table></figure><br><code>supervisorctl reread</code> 命令只是更新所做的修改，但不会重启所有管理的程序，即使它们的配置已经发生更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><p><code>update</code> 命令重启那些配置发生更改的程序。<br>如果是新增的配置则这时变为可用，但不会自动启动，除非 supervisor 服务重启或系统重启（即使配置中 autostart=true）。</p><p>要启动新的应用程序，例如app2，使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start app2</span><br></pre></td></tr></table></figure></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>重启 supervisior 服务失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service supervisor restart</span><br><span class="line">Failed to restart supervisor.service: Unit supervisor.service is masked.</span><br></pre></td></tr></table></figure></p><h2 id="用-Supervisor-运行-Shadowsocks"><a href="#用-Supervisor-运行-Shadowsocks" class="headerlink" title="用 Supervisor 运行 Shadowsocks"></a>用 Supervisor 运行 Shadowsocks</h2><p><a href="https://github.com/shadowsocks/shadowsocks/wiki/%E7%94%A8-Supervisor-%E8%BF%90%E8%A1%8C-Shadowsocks" target="_blank" rel="noopener">用 Supervisor 运行 Shadowsocks</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/savorboard/p/dotnetcore-supervisor.html" target="_blank" rel="noopener">ASP.NET Core Linux下为 dotnet 创建守护进程（必备知识）</a><br><a href="http://blog.csdn.net/orangleliu/article/details/45057377" target="_blank" rel="noopener"> [supervisor] 使用小记(入门教程)</a><br><a href="http://liyangliang.me/posts/2015/06/using-supervisor/" target="_blank" rel="noopener">使用 supervisor 管理进程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-Supervisor&quot;&gt;&lt;a href=&quot;#关于-Supervisor&quot; class=&quot;headerlink&quot; title=&quot;关于 Supervisor&quot;&gt;&lt;/a&gt;关于 Supervisor&lt;/h2&gt;&lt;p&gt;Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。&lt;/p&gt;
&lt;p&gt;supervisor 是一个 C/S 模型的程序，由 server 和 client 模块组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;supervisord&lt;/li&gt;
&lt;li&gt;supervisorctl&lt;br&gt;supervisorctl 是命令行工具，我们通过它可以在终端操作 supervisord ，例如启动、停止任务，详细的命令可使用&lt;code&gt;supervisorctl -h&lt;/code&gt; 查看。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://supervisord.org/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="supervisor" scheme="http://blog.xingzheng.top/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 笔记</title>
    <link href="http://blog.xingzheng.top/2017/06/16/NET-Core%E7%AC%94%E8%AE%B0.html"/>
    <id>http://blog.xingzheng.top/2017/06/16/NET-Core%E7%AC%94%E8%AE%B0.html</id>
    <published>2017-06-16T12:34:54.000Z</published>
    <updated>2017-06-16T12:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-NET-Core-和-ASP-NET-Core"><a href="#什么是-NET-Core-和-ASP-NET-Core" class="headerlink" title="什么是 .NET Core 和 ASP.NET Core"></a>什么是 .NET Core 和 ASP.NET Core</h2><h3 id="NET-Core"><a href="#NET-Core" class="headerlink" title=".NET Core"></a>.NET Core</h3><p>.NET Core 是一个模块化、跨平台、云优化的 .NET Framework 版本，可将 .NET Core 看作是 .NET Framework 在 .NET Framework 基类库 (BCL) 的跨平台版本，它实现 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard" target="_blank" rel="noopener">.NET Standard</a> 规范。</p><p>.NET Core 包含 一个.NET <a href="https://github.com/dotnet/coreclr" target="_blank" rel="noopener">运行时</a>，一组<a href="https://github.com/dotnet/corefx" target="_blank" rel="noopener">框架库</a>，.NET Core SDK 和 “dotnet” 应用主机。</p><p>目前正式版是 <a href="https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.0.7-download.md" target="_blank" rel="noopener">.NET Core 2.0.7</a>，包含<code>.NET Core Runtime 2.0.7</code> 和<code>.NET Core SDK 2.1.105</code> ，实现 .NET Standard 2.0规范。 </p><p>它的一个主要特性是，只需要为构建的应用程序安装需要的特性，减少耦合度。这使在同一台机器上不同版本的程序共存成为可能，而且没有兼容性问题。</p><h3 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h3><p>ASP.NET Core 是对 ASP.NET 的完全重写，基于 OWIN ，目标是成为跨平台、完全开源、没有向后兼容限制的框架。  </p><h2 id="从CLI开始"><a href="#从CLI开始" class="headerlink" title="从CLI开始"></a>从CLI开始</h2><p><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/" target="_blank" rel="noopener">CLI (command line interface)</a>  </p><ul><li><code>new</code>, to create a new .NET Core project.</li><li><code>restore</code>, to download all dependencies from NuGet.</li><li><code>build</code>, to compile the projects.</li><li><code>publish</code>, to generate a self-contained folder used for deployment.</li><li><code>run</code>, to run a project, building it if it’s not already built.</li><li><code>pack</code>, to package the project as a NuGet package.</li><li><code>msbuild</code>, used as a proxy for the standard MSBuild command. </li><li><code>add package</code> &lt;PACKAGE_NAME&gt;, Adds a package reference to a project file</li></ul><p>.NET Core 支持许多不同的操作系统，但是每个操作系统都有一个特定的标志：Runtime IDentifier（RID），格式是：<code>[os].[version]-[arch] (e.g, osx.10.11-x64)</code>。</p><a id="more"></a><h2 id="ASP-NET-Core-1"><a href="#ASP-NET-Core-1" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><h3 id="启动-Web-App"><a href="#启动-Web-App" class="headerlink" title="启动 Web App"></a>启动 Web App</h3><h4 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h4><h4 id="Startup-cs"><a href="#Startup-cs" class="headerlink" title="Startup.cs"></a>Startup.cs</h4><h2 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入(Dependency Injection)"></a>依赖注入(Dependency Injection)</h2><p>IoC(Inversion of Control)容器的职责：  </p><ul><li>控制系统中所有对象的创建</li><li>注入正确的依赖</li><li>管理创建的对象的生命线</li></ul><p>有三种方式指定服务的生命周期：  </p><ol><li>Transient<br>用作轻量级的服务，不需要保持任何状态，快速实例化，每次需要时都会创建一个类的新实例。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;IClock,Clock&gt;()</span><br></pre></td></tr></table></figure><ol start="2"><li>Scoped<br>一般用在需要保持状态的服务，这些状态只对当前请求有用，像仓储类和数据访问类。<br>作为<code>scoped</code>注册的Services会在请求开始的时候被创建，同一个请求中每次需要这个类的时候都会重用这个实例。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IRepository, Repository&gt;()</span><br></pre></td></tr></table></figure><ol start="3"><li>Singleton<br>服务作为单例被注册。服务的实例在第一次需要时被创建，在整个应用程序的运行期内都会被重用。这样的Services一般用作保存应用程序状态，就像内存内缓存或类似的方式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IApplicationCache, ApplicationCache&gt;()</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用依赖注入"><a href="#使用依赖注入" class="headerlink" title="使用依赖注入"></a>使用依赖注入</h3><p>使用 ASP.NET Core MVC 需要引入Nuget包 <code>Microsoft.AspNetCore.Mvc</code>。</p><h2 id="环境（Environments）"><a href="#环境（Environments）" class="headerlink" title="环境（Environments）"></a>环境（Environments）</h2><p>每个应用程序都至少要处理至少2个或更多的环境，如开发环境、生产环境，和一些情况下的模拟环境。  </p><h3 id="旧方式"><a href="#旧方式" class="headerlink" title="旧方式"></a>旧方式</h3><p>web.config <strong>IHostingEnvironment</strong>和预处理指令。<br>发生在<strong>编译</strong>阶段。</p><h3 id="新方式"><a href="#新方式" class="headerlink" title="新方式"></a>新方式</h3><p><code>IHostingEnvironment</code> 接口。 </p><p><code>IHostingEnvironment</code> 的实现类读取一个指定的名叫 <code>IHostingEnvironment</code> 的环境变量，并检查它的值。如果是 <strong>Development</strong>，表示运行在开发环境，以此类推。  </p><p>这种方法可以在运行阶段在不同的环境之间切换，而不像旧的方式只能在编译阶段处理。</p><p>Startup类也可以使用约定的命名方式，来配置环境。如当前环境是Development，那么新建一个 <code>StartupDevelopment</code> 类，则 <code>Main</code> 方法中的<code>.UseStartup&lt;Startup&gt;</code>，能自动切换相应的类，只要遵循正确的约定（<u>方法名+环境名</u>）。  </p><p>同样的约定也适用于<code>Startup</code>中的方法，如定义方法<code>ConfigureDevelopment</code>，它同样会在<code>Development</code>环境中替换<code>Configure</code>方法。  </p><h3 id="创建自定义的环境"><a href="#创建自定义的环境" class="headerlink" title="创建自定义的环境"></a>创建自定义的环境</h3><p>比如需要一个<code>QualityAssurance</code>的环境，则可以扩展 <code>IHostingEnvironment</code> 的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.Hosting;</span><br><span class="line"></span><br><span class="line">namespace Syncfusion.Asp.Net.Core.Succinctly.Environments.Extensions </span><br><span class="line">&#123;</span><br><span class="line">    public static class HostingEnvironmentExtensions </span><br><span class="line">    &#123;</span><br><span class="line">        public static bool IsQualityAssurance(this IHostingEnvironment hostingEnvironment)</span><br><span class="line">        &#123;</span><br><span class="line">            return hostingEnvironment.EnvironmentName &#x3D;&#x3D; &quot;QualityAssurance&quot;;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong><code>IHostingEnvironment</code></strong> 也可以用在视图和配置文件中。  </p><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>引用Nuget包 <code>Microsoft.AspNetCore.StaticFiles</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用静态文件，静态文件需要存放在wwwroot文件夹下</span><br><span class="line">app.UseStaticFiles();</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个单页应用里，当访问域名时需要返回默认文档（default.html,default.htm,index.html,index.htm)</span><br><span class="line">&#x2F;&#x2F; 如果不设置UseFileServer，则会显示一个空白页</span><br><span class="line">app.UseFileServer();</span><br></pre></td></tr></table></figure></p><h2 id="错误处理和异常页面"><a href="#错误处理和异常页面" class="headerlink" title="错误处理和异常页面"></a>错误处理和异常页面</h2><p>从某种角度来看，你可以说一个好的应用程序要能够在最短的时间内识别错误并将最好的反馈返回给用户。<br>日志框架、异常处理、自定义错误页面。  </p><h3 id="开发者异常页面"><a href="#开发者异常页面" class="headerlink" title="开发者异常页面"></a>开发者异常页面</h3><p>Nuget包 <code>Microsoft.AspNetCore.Diagnostics</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (_env.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseDeveloperExceptionPage(); </span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    app.UseStatusCodePagesWithRedirects(&quot;~&#x2F;errors&#x2F;&#123;0&#125;.html&quot;); </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; app.UseStatusCodePagesWithReExecute(&quot;~&#x2F;errors&#x2F;&#123;0&#125;&quot;);     &#x2F;&#x2F; MVC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="配置文件（appsettings-json）"><a href="#配置文件（appsettings-json）" class="headerlink" title="配置文件（appsettings.json）"></a>配置文件（appsettings.json）</h2><h3 id="两个规则"><a href="#两个规则" class="headerlink" title="两个规则"></a>两个规则</h3><ul><li><p>规则1： 每个环境单独对应一个json文件<br><code>appsettings.json</code> 和 <code>appsettings.Development.json</code>、<code>appsettings.Production.json</code>。  </p></li><li><p>规则2：每个文件中只写自己独有的配置项<br>ASP.NET Core 会自动合并这些文件，只覆盖在相应环境文件中指定的配置项。  </p></li></ul><p>示例：<br>appsettings.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"database"</span>: &#123;</span><br><span class="line">    <span class="attr">"databaseName"</span>: <span class="string">"my-db-name"</span>,</span><br><span class="line">    <span class="attr">"serverHost"</span>: <span class="string">"mySqlHost"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">1433</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"username"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"password"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"facebook"</span>: &#123;</span><br><span class="line">    <span class="attr">"appId"</span>: <span class="string">"app-id"</span>,</span><br><span class="line">    <span class="attr">"appSecret"</span>: <span class="string">"app-secret"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"smtp"</span>: &#123;</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"mysuperhost.mysuperdomain.com"</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"imperugo@gmail.com"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"my-super-secret-password"</span>,</span><br><span class="line">    <span class="attr">"enableSsl"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">587</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>appsettings.Development.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"database"</span>: &#123;</span><br><span class="line">    <span class="attr">"databaseName"</span>: <span class="string">"my-development-db-name"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>appsettings.Production.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"database"</span>: &#123;</span><br><span class="line">    <span class="attr">"databaseName"</span>: <span class="string">"my-production-db-name"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>创建一个结构和JSON结构一致的C#类，通过类以更舒服的方式得到配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Configuration</span><br><span class="line">&#123;</span><br><span class="line">    public DatabaseConfiguration Database &#123; get; set; &#125;</span><br><span class="line">    public FacebookConfiguration Facebook &#123; get; set; &#125;</span><br><span class="line">    public SmtpConfiguration SmtpConfiguration &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DatabaseConfiguration</span><br><span class="line">&#123;</span><br><span class="line">    public string DatabaseName &#123; get; set; &#125;</span><br><span class="line">    public string ServerHost &#123; get; set; &#125;</span><br><span class="line">    public int Port &#123; get; set; &#125;49</span><br><span class="line">    public string Username &#123; get; set; &#125;</span><br><span class="line">    public string Password &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public string ConnectionString &#x3D;&gt; $&quot;Server&#x3D;tcp:&#123;ServerHost&#125;,&#123;Port</span><br><span class="line">        &#125;;Database&#x3D;&#123;DatabaseName&#125;;User ID&#x3D;&#123;Username&#125;;Password&#x3D;&#123;Password&#125;;Encrypt&#x3D;</span><br><span class="line">        True;TrustServerCertificate&#x3D;False;Connection Timeout&#x3D;30;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><h3 id="初始化配置类的实例"><a href="#初始化配置类的实例" class="headerlink" title="初始化配置类的实例"></a>初始化配置类的实例</h3><p>在<code>Startup</code>类中编写代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需引入以下包</span><br><span class="line">using Microsoft.Extensions.Configuration.EnvironmentVariables</span><br><span class="line">using Microsoft.Extensions.Configuration.FileExtensions</span><br><span class="line">using Microsoft.Extensions.Configuration.Json</span><br><span class="line">using Microsoft.Extensions.Configuration.Binder</span><br><span class="line"></span><br><span class="line">public class Startup</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">    public Startup(IConfiguration configuration)</span><br><span class="line">    &#123;</span><br><span class="line">        Configuration &#x3D; configuration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void ConfigureServices(IServiceCollection services)</span><br><span class="line">    &#123;</span><br><span class="line">        services.Configure&lt;Class&gt;(Configuration);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 其它代码省略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入配置对象"><a href="#注入配置对象" class="headerlink" title="注入配置对象"></a>注入配置对象</h3><p>将配置类的实例以单例的方式注入，这样可以在应用程序的任何需要配置信息的地方使用，例如Controller、Service等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.Configuration;</span><br><span class="line">using Microsoft.Extensions.Options;</span><br><span class="line"></span><br><span class="line">public class MySimpleService</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 构造器方式注入</span><br><span class="line">    public readonly Configuration _configuration;</span><br><span class="line">    public MySimpleService(IOptions&lt;Configuration&gt; config)</span><br><span class="line">    &#123;</span><br><span class="line">        _configuration &#x3D; config.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="日志（Logging）"><a href="#日志（Logging）" class="headerlink" title="日志（Logging）"></a>日志（Logging）</h2><p>ASP.NET Core 提供了日志工具，并且和所有的包都集成了。  </p><h3 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h3><p>选择日志的输出方式，例如 <code>console application</code>,<code>trace source</code>,<code>event log</code>。<br>对Kestrel来说，使用控制台输出更有帮助。<br>添加包 <code>Microsoft.Extensions.Logging.Console</code>，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)</span><br><span class="line">&#123;</span><br><span class="line">    loggerFactory.AddConsole();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ASP.NET Core 的日志级别有6种，定义在枚举 <code>LogLevel</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum LogLevel</span><br><span class="line">&#123;</span><br><span class="line">    Trace &#x3D; 0,</span><br><span class="line">    Debug &#x3D; 1,</span><br><span class="line">    Information &#x3D; 2,</span><br><span class="line">    Warning &#x3D; 3,</span><br><span class="line">    Error &#x3D; 4,</span><br><span class="line">    Critical &#x3D; 5,</span><br><span class="line">    None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以指定要需要的日志范围，如在生产环境想记录 Warning 或 Error 级别以上的日志，调用 <code>AddConsole</code> 的重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;string, LogLevel, bool&gt; filter &#x3D; (name, level) &#x3D;&gt; level &gt;&#x3D; LogLevel.Error;</span><br><span class="line">loggerFactory.AddConsole(filter);</span><br></pre></td></tr></table></figure><br>表示日志框架只记录 <code>Error</code> 级别以上的日志。  </p><h3 id="在程序中使用日志"><a href="#在程序中使用日志" class="headerlink" title="在程序中使用日志"></a>在程序中使用日志</h3><p>得益于依赖注入，我们只需要把日志的实例注入到类的构造函数中，就可以使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyService</span><br><span class="line">&#123;</span><br><span class="line">    private readonly ILogger&lt;MyService&gt; _logger;</span><br><span class="line">    public MyService(ILogger&lt;MyService&gt; logger) </span><br><span class="line">    &#123;</span><br><span class="line">            _logger &#x3D; logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DoSomething()</span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(&quot;Doing something ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="创建自定义的Logger"><a href="#创建自定义的Logger" class="headerlink" title="创建自定义的Logger"></a>创建自定义的Logger</h3><p>参考：<br>Serilog at <a href="https://github.com/serilog/serilog-extensions-logging" target="_blank" rel="noopener">https://github.com/serilog/serilog-extensions-logging</a>.</p><ul><li>Elmah.io at <a href="https://github.com/elmahio/Elmah.Io.Extensions.Logging" target="_blank" rel="noopener">https://github.com/elmahio/Elmah.Io.Extensions.Logging</a>.</li><li>Loggr at <a href="https://github.com/imobile3/Loggr.Extensions.Logging" target="_blank" rel="noopener">https://github.com/imobile3/Loggr.Extensions.Logging</a>.</li><li>NLog at <a href="https://github.com/NLog/NLog.Extensions.Logging" target="_blank" rel="noopener">https://github.com/NLog/NLog.Extensions.Logging</a>.</li><li>Slack at <a href="https://github.com/imperugo/Microsoft.Extensions.Logging.Slack" target="_blank" rel="noopener">https://github.com/imperugo/Microsoft.Extensions.Logging.Slack</a>.</li><li>MongoDb at <a href="https://github.com/imperugo/Microsoft.Extensions.Logging.MongoDb" target="_blank" rel="noopener">https://github.com/imperugo/Microsoft.Extensions.Logging.MongoDb</a>.</li></ul><h2 id="应用程序框架（Application-Framework）"><a href="#应用程序框架（Application-Framework）" class="headerlink" title="应用程序框架（Application Framework）"></a>应用程序框架（Application Framework）</h2><h3 id="WebAPI"><a href="#WebAPI" class="headerlink" title="WebAPI"></a>WebAPI</h3><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h4><p><code>Startup.Configure()</code> 中 <code>app.UseMvcWithDefaultRoute();</code>,等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.UseMvc(routes &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    routes.MapRoute(</span><br><span class="line">        name: &quot;default&quot;,</span><br><span class="line">        template: &quot;&#123;controller&#x3D;Home&#125;&#x2F;&#123;action&#x3D;Index&#125;&#x2F;&#123;id?&#125;&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>ASP.NET Core MVC 的大多用法和之前版本的 ASP.NET MVC 很类似，但是在视图方面有以下新特性：</p><ul><li>TagHelper</li><li>ViewComponent</li></ul><h4 id="TagHelper"><a href="#TagHelper" class="headerlink" title="TagHelper"></a>TagHelper</h4><p>好处是，当增加更多属性时会很清晰。比较以下代码：<br>之前的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Html.TextBoxFor(m&#x3D;&gt;m.FirstName)</span><br><span class="line">@Html.TextBoxFor(m&#x3D;&gt;m.Email, new &#123; @class &#x3D; &quot;form-control&quot; &#125;)</span><br></pre></td></tr></table></figure><br>TagHelper 的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input asp-for&#x3D;&quot;FirstName&quot; &#x2F;&gt; </span><br><span class="line">&lt;input asp-for&#x3D;&quot;FirstName&quot; class&#x3D;&quot;form-control&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></p><p>还有一些 TagHelper 能够管理缓存，根据不同环境渲染不同的 HTML 元素，管理脚本回调或css文件。默认项目模板的 <code>View\Shared\_Layout.cshtml</code> 下有很多这样的 TagHelper。</p><h5 id="创建自定义-TagHelper"><a href="#创建自定义-TagHelper" class="headerlink" title="创建自定义 TagHelper"></a>创建自定义 TagHelper</h5><p>继承 <code>TagHelper</code> 类，实现方法 <code>Process</code> 或对应的异步方法 <code>ProcessAsync</code>。</p><h4 id="View-components"><a href="#View-components" class="headerlink" title="View components"></a>View components</h4><p>View components 和 partial views 很相似，但是比 partial views 更强大，用来解决不同的问题。  </p><h5 id="如何写一个-View-components"><a href="#如何写一个-View-components" class="headerlink" title="如何写一个 View components"></a>如何写一个 View components</h5><p>继承 <code>ViewComponent</code> 类，实现方法 <code>Invoke</code> 或对应的异步方法 <code>InvokeAsync</code>。<br>对应 ViewComponent 的视图文件，必须放在 <code>Views\Shared\Components\&lt;component-name&gt;\Default.cshtml</code>。</p><h2 id="如何部署-ASP-NET-Core-应用程序"><a href="#如何部署-ASP-NET-Core-应用程序" class="headerlink" title="如何部署 ASP.NET Core 应用程序"></a>如何部署 ASP.NET Core 应用程序</h2><h3 id="在IIS下部署"><a href="#在IIS下部署" class="headerlink" title="在IIS下部署"></a>在IIS下部署</h3><p>每个 ASP.NET Core 应用程序都是自寄宿的，能够不依赖外部的Web服务器运行。但是当需要优化性能、响应更快时，Kestrel 就缺少像 IIS 这样成熟的 Web 服务器的管理选项。<br>自寄宿的应用程序需要用不同的途径寄宿在 IIS 中。IIS 只是作为一个代理服务器，接收客户端的请求并将它们转发给 Kestrel 上的 ASP.NET Core 应用程序，等处理完成之后，IIS 再将响应返回给客户端。</p><p>为了在 IIS 中寄宿 ASP.NET Core，需要安装 <strong>AspNetCoreModule</strong>。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-NET-Core-和-ASP-NET-Core&quot;&gt;&lt;a href=&quot;#什么是-NET-Core-和-ASP-NET-Core&quot; class=&quot;headerlink&quot; title=&quot;什么是 .NET Core 和 ASP.NET Core&quot;&gt;&lt;/a&gt;什么是 .NET Core 和 ASP.NET Core&lt;/h2&gt;&lt;h3 id=&quot;NET-Core&quot;&gt;&lt;a href=&quot;#NET-Core&quot; class=&quot;headerlink&quot; title=&quot;.NET Core&quot;&gt;&lt;/a&gt;.NET Core&lt;/h3&gt;&lt;p&gt;.NET Core 是一个模块化、跨平台、云优化的 .NET Framework 版本，可将 .NET Core 看作是 .NET Framework 在 .NET Framework 基类库 (BCL) 的跨平台版本，它实现 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;.NET Standard&lt;/a&gt; 规范。&lt;/p&gt;
&lt;p&gt;.NET Core 包含 一个.NET &lt;a href=&quot;https://github.com/dotnet/coreclr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;运行时&lt;/a&gt;，一组&lt;a href=&quot;https://github.com/dotnet/corefx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;框架库&lt;/a&gt;，.NET Core SDK 和 “dotnet” 应用主机。&lt;/p&gt;
&lt;p&gt;目前正式版是 &lt;a href=&quot;https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.0.7-download.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;.NET Core 2.0.7&lt;/a&gt;，包含&lt;code&gt;.NET Core Runtime 2.0.7&lt;/code&gt; 和&lt;code&gt;.NET Core SDK 2.1.105&lt;/code&gt; ，实现 .NET Standard 2.0规范。 &lt;/p&gt;
&lt;p&gt;它的一个主要特性是，只需要为构建的应用程序安装需要的特性，减少耦合度。这使在同一台机器上不同版本的程序共存成为可能，而且没有兼容性问题。&lt;/p&gt;
&lt;h3 id=&quot;ASP-NET-Core&quot;&gt;&lt;a href=&quot;#ASP-NET-Core&quot; class=&quot;headerlink&quot; title=&quot;ASP.NET Core&quot;&gt;&lt;/a&gt;ASP.NET Core&lt;/h3&gt;&lt;p&gt;ASP.NET Core 是对 ASP.NET 的完全重写，基于 OWIN ，目标是成为跨平台、完全开源、没有向后兼容限制的框架。  &lt;/p&gt;
&lt;h2 id=&quot;从CLI开始&quot;&gt;&lt;a href=&quot;#从CLI开始&quot; class=&quot;headerlink&quot; title=&quot;从CLI开始&quot;&gt;&lt;/a&gt;从CLI开始&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CLI (command line interface)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;, to create a new .NET Core project.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restore&lt;/code&gt;, to download all dependencies from NuGet.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt;, to compile the projects.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publish&lt;/code&gt;, to generate a self-contained folder used for deployment.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;, to run a project, building it if it’s not already built.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pack&lt;/code&gt;, to package the project as a NuGet package.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msbuild&lt;/code&gt;, used as a proxy for the standard MSBuild command. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;add package&lt;/code&gt; &amp;lt;PACKAGE_NAME&amp;gt;, Adds a package reference to a project file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET Core 支持许多不同的操作系统，但是每个操作系统都有一个特定的标志：Runtime IDentifier（RID），格式是：&lt;code&gt;[os].[version]-[arch] (e.g, osx.10.11-x64)&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ASP.NET Core" scheme="http://blog.xingzheng.top/tags/ASP-NET-Core/"/>
    
  </entry>
  
  <entry>
    <title>.NET版本和运行时版本的关系</title>
    <link href="http://blog.xingzheng.top/2017/04/23/NET%E7%89%88%E6%9C%AC%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%B3%E7%B3%BB.html"/>
    <id>http://blog.xingzheng.top/2017/04/23/NET%E7%89%88%E6%9C%AC%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%B3%E7%B3%BB.html</id>
    <published>2017-04-23T23:43:07.000Z</published>
    <updated>2017-04-23T23:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>.NET Framework 版本号和 .NET 运行时版本号是不同的，运行时版本号可以通过<code>System.Environment.Version</code>来查看。对于 .NET 4.5 来说，运行时最新版本仍然是 <code>4.0.30319.*</code>，只是修订版本号发生了变化（一些安全更新）。<br>以下是目前的一些运行时版本的例子：</p><p><strong>Base 4.0</strong></p><ul><li>4.0.30319.1 = .NET 4.0 RTM</li><li>4.0.30319.269 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS12-035 GDR security update)</li><li>4.0.30319.276 = .NET 4.0 on Windows XP SP3 (4.0.3 Runtime update)</li><li>4.0.30319.296 = .NET 4.0 on Windows XP SP3, 7 (with MS12-074 GDR security update)</li><li>4.0.30319.544 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS12-035 LDR security update)</li><li>4.0.30319.1008 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS13-052 GDR security update)</li><li>4.0.30319.1022 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS14-009 GDR security update)</li><li>4.0.30319.1026 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS14-057 GDR security update)</li><li>4.0.30319.2034 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS14-009 LDR security update)</li></ul><a id="more"></a><p><strong>4.5</strong></p><ul><li>4.0.30319.17626 = .NET 4.5 RC</li><li>4.0.30319.17929 = .NET 4.5 RTM</li><li>4.0.30319.18010 = .NET 4.5 on Windows 8</li><li>4.0.30319.18052 = .NET 4.5 on Windows 7 SP1 64-bit</li><li>4.0.30319.18063 = .NET 4.5 on Windows 7 SP1 64-bit (with MS14-009 security update)</li></ul><p><strong>4.5.1</strong></p><ul><li>4.0.30319.18408 = .NET 4.5.1 on Windows 7 SP1 64-bit</li><li>4.0.30319.18444 = .NET 4.5.1 on Windows 7 SP1 64-bit (with MS14-009 security update)</li><li>4.0.30319.34014 = .NET 4.5.1 on Windows 8.1 64-bit</li></ul><p><strong>4.5.2</strong></p><ul><li>4.0.30319.34209 = .NET 4.5.2 on Windows 7 SP1 64-bit</li><li>4.0.30319.34209 = .NET 4.5.2 on Windows 8.1 64-bit</li></ul><p><strong>4.6</strong></p><ul><li>4.0.30319.42000 = .NET 4.6 on Windows 8.1 64-bit</li></ul><p>参考：  <a href="http://stackoverflow.com/questions/12971881/how-to-reliably-detect-the-actual-net-4-5-version-installed" target="_blank" rel="noopener">How to reliably detect the actual .NET 4.5 version installed</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.NET Framework 版本号和 .NET 运行时版本号是不同的，运行时版本号可以通过&lt;code&gt;System.Environment.Version&lt;/code&gt;来查看。对于 .NET 4.5 来说，运行时最新版本仍然是 &lt;code&gt;4.0.30319.*&lt;/code&gt;，只是修订版本号发生了变化（一些安全更新）。&lt;br&gt;以下是目前的一些运行时版本的例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Base 4.0&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4.0.30319.1 = .NET 4.0 RTM&lt;/li&gt;
&lt;li&gt;4.0.30319.269 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS12-035 GDR security update)&lt;/li&gt;
&lt;li&gt;4.0.30319.276 = .NET 4.0 on Windows XP SP3 (4.0.3 Runtime update)&lt;/li&gt;
&lt;li&gt;4.0.30319.296 = .NET 4.0 on Windows XP SP3, 7 (with MS12-074 GDR security update)&lt;/li&gt;
&lt;li&gt;4.0.30319.544 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS12-035 LDR security update)&lt;/li&gt;
&lt;li&gt;4.0.30319.1008 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS13-052 GDR security update)&lt;/li&gt;
&lt;li&gt;4.0.30319.1022 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS14-009 GDR security update)&lt;/li&gt;
&lt;li&gt;4.0.30319.1026 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS14-057 GDR security update)&lt;/li&gt;
&lt;li&gt;4.0.30319.2034 = .NET 4.0 on Windows XP SP3, 7, 7 SP1 (with MS14-009 LDR security update)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term=".NET" scheme="http://blog.xingzheng.top/tags/NET/"/>
    
      <category term="运行时" scheme="http://blog.xingzheng.top/tags/%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
      <category term="Runtime" scheme="http://blog.xingzheng.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>第一个Cordova App</title>
    <link href="http://blog.xingzheng.top/2017/04/21/%E7%AC%AC%E4%B8%80%E4%B8%AACordova-App.html"/>
    <id>http://blog.xingzheng.top/2017/04/21/%E7%AC%AC%E4%B8%80%E4%B8%AACordova-App.html</id>
    <published>2017-04-21T23:51:33.000Z</published>
    <updated>2017-04-21T23:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cordova-搭建开发环境"><a href="#Cordova-搭建开发环境" class="headerlink" title="Cordova 搭建开发环境"></a>Cordova 搭建开发环境</h2><h3 id="安装-Android-SDK"><a href="#安装-Android-SDK" class="headerlink" title="安装 Android SDK"></a>安装 Android SDK</h3><p>可以在网上找到各种安装方式，不再赘述。我这里将Android SDK 安装在以下目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Android\SDK</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<br>要将 Android SDK 所在目录添加到环境变量中，否则 Cordova 可能找不到 Android SDK。</p></blockquote><h3 id="安装-Cordova"><a href="#安装-Cordova" class="headerlink" title="安装 Cordova"></a>安装 Cordova</h3><p>因为 Cordova 命令行工具是作为一个 npm 包来分发的，因此需要预先安装 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a> ，并且能够调用 <strong>node</strong> 和  <strong>npm</strong>命令 。<br>假设已经安装好 Node.js 以及 npm，利用 npm 工具能自动下载 Cordova 模块。</p><ul><li>Windows 下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;npm install -g cordova</span><br></pre></td></tr></table></figure></li><li>on OS X and Linux:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g cordova</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="创建App"><a href="#创建App" class="headerlink" title="创建App"></a>创建App</h3><p>切换到你的源代码目录，创建一个 Cordova 项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova create hello com.example.hello HelloWorld</span><br></pre></td></tr></table></figure><br>这将会创建 Cordova app 需要的文件夹结构，默认情况， <strong>cordova create</strong> 脚本会生成一个基于Web应用的骨架，主页是项目下 <em>www/Index.html</em> 文件。</p><h3 id="添加平台"><a href="#添加平台" class="headerlink" title="添加平台"></a>添加平台</h3><p>以下所有命令都需要在项目目录下运行，或任意的子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd hello</span><br></pre></td></tr></table></figure><br>添加你的app的目标平台，这里我们会添加 ‘ios’ 和 ‘android’ 平台，并且确保他们被保存到 <strong>config.xml</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cordova platform add ios --save</span><br><span class="line">$ cordova platform add android --save</span><br></pre></td></tr></table></figure><br>检查当前的平台集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova platform ls</span><br></pre></td></tr></table></figure><br>我的环境执行结果如下：<br><img src="http://ojm289en8.bkt.clouddn.com/image/20170225/cordova-check-platforms.png" alt=""></p><h3 id="检查必备的构建工具"><a href="#检查必备的构建工具" class="headerlink" title="检查必备的构建工具"></a>检查必备的构建工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cordova requirements</span><br></pre></td></tr></table></figure><p>可能会出现如下错误信息：<br><img src="http://ojm289en8.bkt.clouddn.com/image/20170225/Cordova-requirements-Android-SDK-failed.png" alt=""><br>意思是没有找到 Android SDK。 如果没有安装在默认位置（一般在 C:\Program Files(x86)\Android\SDK），并且没有配置正确的环境变量，就会提示这样的错误。</p><p>打开环境变量窗口，根据提示在“用户变量”里添加一项变量，变量名为“ANDROID_HOME”，值为 Android SDK 安装目录：<br><img src="http://ojm289en8.bkt.clouddn.com/image/20170225/Android-SDK-Envrionment.png" alt=""><br>点击“确定”保存，然后重启CMD，切换目录到 Cordova 项目，再次执行命令，可以看到不再有警告和错误提示：<br><img src="http://ojm289en8.bkt.clouddn.com/image/20170225/Cordova-Check-Android-SDK-Envrionment-Successfully.png" alt=""></p><p><strong>检查结果：</strong></p><blockquote><p>JDK：已安装<br>Android SDK：已安装<br>Anroid 目标平台： 已安装 android-19,….<br>Gradle：已安装 </p></blockquote><h3 id="编译App"><a href="#编译App" class="headerlink" title="编译App"></a>编译App</h3><p>任何初始化工作都要写在 <em>www/js/index.js</em>  的 <em>deviceready</em> 事件处理程序中。<br>运行以下命令将项目构建所有的平台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build</span><br></pre></td></tr></table></figure><br>你可以限定构建的平台范围，这里以 -‘’android’ 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build android</span><br></pre></td></tr></table></figure></p><p>在构建过程中我遇到如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Unable to start the daemon process.</span><br><span class="line">This problem might be caused by incorrect configuration of the daemon.</span><br><span class="line">For example, an unrecognized jvm option is used.</span><br><span class="line">Please refer to the user guide chapter on the daemon at http:&#x2F;&#x2F;gradle.org&#x2F;docs&#x2F;1.8&#x2F;userguide&#x2F;gradle_daemon.html</span><br><span class="line">Please read below process output to find out more: </span><br><span class="line">---------------------------------------------------</span><br><span class="line">Error occurred during initialization of VM</span><br><span class="line">Could not reserve enough space for 2097152KB object heap</span><br></pre></td></tr></table></figure></p><p>Google 后查到，需要在环境变量中添加一个变量：<br><code>_JAVA_OPTIONS : -Xmx512M</code></p><p>参考： <a href="http://stackoverflow.com/questions/4401396/could-not-reserve-enough-space-for-object-heap" target="_blank" rel="noopener">StackOverFlow</a></p><p>再次编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1 mins 45.002 secs</span><br><span class="line">Built the following apk(s):</span><br><span class="line">        D:&#x2F;CordovaDemo&#x2F;hello&#x2F;platforms&#x2F;android&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;android-debug.apk</span><br></pre></td></tr></table></figure><br>编译成功，并输出debug apk文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cordova-搭建开发环境&quot;&gt;&lt;a href=&quot;#Cordova-搭建开发环境&quot; class=&quot;headerlink&quot; title=&quot;Cordova 搭建开发环境&quot;&gt;&lt;/a&gt;Cordova 搭建开发环境&lt;/h2&gt;&lt;h3 id=&quot;安装-Android-SDK&quot;&gt;&lt;a href=&quot;#安装-Android-SDK&quot; class=&quot;headerlink&quot; title=&quot;安装 Android SDK&quot;&gt;&lt;/a&gt;安装 Android SDK&lt;/h3&gt;&lt;p&gt;可以在网上找到各种安装方式，不再赘述。我这里将Android SDK 安装在以下目录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C:\Android\SDK&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;要将 Android SDK 所在目录添加到环境变量中，否则 Cordova 可能找不到 Android SDK。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-Cordova&quot;&gt;&lt;a href=&quot;#安装-Cordova&quot; class=&quot;headerlink&quot; title=&quot;安装 Cordova&quot;&gt;&lt;/a&gt;安装 Cordova&lt;/h3&gt;&lt;p&gt;因为 Cordova 命令行工具是作为一个 npm 包来分发的，因此需要预先安装 &lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt; ，并且能够调用 &lt;strong&gt;node&lt;/strong&gt; 和  &lt;strong&gt;npm&lt;/strong&gt;命令 。&lt;br&gt;假设已经安装好 Node.js 以及 npm，利用 npm 工具能自动下载 Cordova 模块。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows 下：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C:\&amp;gt;npm install -g cordova&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;on OS X and Linux:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo npm install -g cordova&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Cordova" scheme="http://blog.xingzheng.top/tags/Cordova/"/>
    
  </entry>
  
  <entry>
    <title>Framework7使用小结</title>
    <link href="http://blog.xingzheng.top/2017/04/21/Framework7%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html"/>
    <id>http://blog.xingzheng.top/2017/04/21/Framework7%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html</id>
    <published>2017-04-21T23:47:42.000Z</published>
    <updated>2017-08-03T15:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Framework7-使用技巧"><a href="#Framework7-使用技巧" class="headerlink" title="Framework7 使用技巧"></a>Framework7 使用技巧</h2><h3 id="控制滚动条位置"><a href="#控制滚动条位置" class="headerlink" title="控制滚动条位置"></a>控制滚动条位置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$(<span class="string">'.page-content'</span>).scrollTop(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="序列化-form-表单元素"><a href="#序列化-form-表单元素" class="headerlink" title="序列化 form 表单元素"></a>序列化 form 表单元素</h3><p>Framework7 中没有提供 jQuery 的 form.serialize() 同名方法。但是提供类似的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.myApp = <span class="keyword">new</span> Framework7(&#123; <span class="comment">// .... &#125;);</span></span><br><span class="line"><span class="keyword">var</span> jsonObj = myApp.formToJSON(<span class="string">'#formId'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Framework7-问题汇总"><a href="#Framework7-问题汇总" class="headerlink" title="Framework7 问题汇总"></a>Framework7 问题汇总</h2><h3 id="confirm-弹出两次的问题"><a href="#confirm-弹出两次的问题" class="headerlink" title="confirm 弹出两次的问题"></a>confirm 弹出两次的问题</h3><p>解决办法：<br>绑定事件时，不要使用<br><code>$$(document).on(&#39;eventname&#39;,&#39;selector&#39;,...)</code>，<br>而是使用<br><code>$$(&#39;selector&#39;).on(&#39;click&#39;,function(){})</code>。  </p><p>参考：<a href="https://github.com/nolimits4web/Framework7/issues/1328" target="_blank" rel="noopener">Confirm modal appear twice after clicking any button</a></p><a id="more"></a><h3 id="返回并刷新上一个页面"><a href="#返回并刷新上一个页面" class="headerlink" title="返回并刷新上一个页面"></a>返回并刷新上一个页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">homeF7View.router.back(&#123;</span><br><span class="line">    url: <span class="string">'url'</span>,</span><br><span class="line">    force: <span class="literal">true</span>,</span><br><span class="line">    ignoreCache: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">homeF7View.router.back(&#123;</span><br><span class="line">    url: <span class="string">'url'</span>,</span><br><span class="line">    context: contextData</span><br><span class="line">    force: <span class="literal">true</span>,</span><br><span class="line">    ignoreCache: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="跨页面回退并刷新"><a href="#跨页面回退并刷新" class="headerlink" title="跨页面回退并刷新"></a>跨页面回退并刷新</h3><p>场景：页面跳转顺序是：“列表页-详情页-编辑页”。现在想在编辑页修改完数据，直接返回到列表页，并刷新列表数据。<br><strong>遇到的问题：</strong><br>返回到列表页后，将模版引擎生成的HTML附加到页面上，页面却是空白。<br>原来是因为Framework7缓存了列表页的DOM结构，查找DOM时找到的是缓存的、当前不可见的DOM元素。<br><strong>解决：</strong><br>将缓存的DOM元素移除，然后刷新HTML，并且不会影响回退效果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$(<span class="string">'div[data-page=payment-list]'</span>).remove();</span><br></pre></td></tr></table></figure></p><h3 id="Tab页激活时也触发了-lt-div-class-quot-view-quot-gt-的show事件"><a href="#Tab页激活时也触发了-lt-div-class-quot-view-quot-gt-的show事件" class="headerlink" title="Tab页激活时也触发了&lt;div class=&quot;view&quot;&gt;的show事件"></a>Tab页激活时也触发了<code>&lt;div class=&quot;view&quot;&gt;</code>的<code>show</code>事件</h3><p>由于这个原因，如果想在Tab页激活时初始化该Tab页事件，那么就不要绑定tab的show事件，绑定view的show事件即可。</p><h3 id="ajax-error-parseerror"><a href="#ajax-error-parseerror" class="headerlink" title="ajax error:parseerror"></a>ajax error:parseerror</h3><p>使用DOM7发送Ajax请求，返回的JSON格式正确，但是总是报错提示：“error:parseerror”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$$.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    method: options.method,</span><br><span class="line">    data: options.data,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 请求成功，调用回调函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 接收到服务端响应后，总是执行到这里，status=parseerror</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ajax error:'</span> + status);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ajax complete.'</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>解决：<br>将<code>dataType:&#39;json&#39;</code>去掉或修改为<code>text</code>，然后使用<code>JSON.parse(json)</code>手动解析服务端JSON数据(我也不知道为啥)。</p><h3 id="infinite-scroll-会触发多次监听事件"><a href="#infinite-scroll-会触发多次监听事件" class="headerlink" title="infinite-scroll 会触发多次监听事件"></a>infinite-scroll 会触发多次监听事件</h3><p><a href="http://framework7.taobao.org/docs/infinite-scroll.html#.WO2JIoh94WV" target="_blank" rel="noopener">API参考</a><br>问题描述：<br>页面往下滚动加载分页数据，但是页面到底部后，会连续多次(四次)触发监听事件，会重复请求同一页的数据。<br>解决方案：<br>其实Demo中已经给出了，就是设置一个loading作为flag，并且用setTimeout延时执行操作，重复的触发会被return。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pageIndex &gt;= pageCount) &#123;</span><br><span class="line">        loading = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Remove preloader</span></span><br><span class="line">        myApp.detachInfiniteScroll(<span class="string">'#chatTabs'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pageIndex++;</span><br><span class="line">    renderView(<span class="string">'append'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="scrollTop到顶端时，会触发-infinite-scroll-的-infinite-事件"><a href="#scrollTop到顶端时，会触发-infinite-scroll-的-infinite-事件" class="headerlink" title="scrollTop到顶端时，会触发 infinite-scroll 的 infinite 事件"></a>scrollTop到顶端时，会触发 infinite-scroll 的 infinite 事件</h3><p>比如滚动到底部后，重新刷新当前页面的第一页数据，希望滚动条滚动到顶端，因此使用 <code>scrollTop(0, 100)</code> 来控制。<br>结果就是，发现会触发 infinite-scroll的infinite事件，连续加载分页的两页数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Framework7-使用技巧&quot;&gt;&lt;a href=&quot;#Framework7-使用技巧&quot; class=&quot;headerlink&quot; title=&quot;Framework7 使用技巧&quot;&gt;&lt;/a&gt;Framework7 使用技巧&lt;/h2&gt;&lt;h3 id=&quot;控制滚动条位置&quot;&gt;&lt;a href=&quot;#控制滚动条位置&quot; class=&quot;headerlink&quot; title=&quot;控制滚动条位置&quot;&gt;&lt;/a&gt;控制滚动条位置&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$(&lt;span class=&quot;string&quot;&gt;&#39;.page-content&#39;&lt;/span&gt;).scrollTop(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;序列化-form-表单元素&quot;&gt;&lt;a href=&quot;#序列化-form-表单元素&quot; class=&quot;headerlink&quot; title=&quot;序列化 form 表单元素&quot;&gt;&lt;/a&gt;序列化 form 表单元素&lt;/h3&gt;&lt;p&gt;Framework7 中没有提供 jQuery 的 form.serialize() 同名方法。但是提供类似的实现：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.myApp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Framework7(&amp;#123; &lt;span class=&quot;comment&quot;&gt;// .... &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; jsonObj = myApp.formToJSON(&lt;span class=&quot;string&quot;&gt;&#39;#formId&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Framework7-问题汇总&quot;&gt;&lt;a href=&quot;#Framework7-问题汇总&quot; class=&quot;headerlink&quot; title=&quot;Framework7 问题汇总&quot;&gt;&lt;/a&gt;Framework7 问题汇总&lt;/h2&gt;&lt;h3 id=&quot;confirm-弹出两次的问题&quot;&gt;&lt;a href=&quot;#confirm-弹出两次的问题&quot; class=&quot;headerlink&quot; title=&quot;confirm 弹出两次的问题&quot;&gt;&lt;/a&gt;confirm 弹出两次的问题&lt;/h3&gt;&lt;p&gt;解决办法：&lt;br&gt;绑定事件时，不要使用&lt;br&gt;&lt;code&gt;$$(document).on(&amp;#39;eventname&amp;#39;,&amp;#39;selector&amp;#39;,...)&lt;/code&gt;，&lt;br&gt;而是使用&lt;br&gt;&lt;code&gt;$$(&amp;#39;selector&amp;#39;).on(&amp;#39;click&amp;#39;,function(){})&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://github.com/nolimits4web/Framework7/issues/1328&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Confirm modal appear twice after clicking any button&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://blog.xingzheng.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="WebApp" scheme="http://blog.xingzheng.top/tags/WebApp/"/>
    
      <category term="Framework7" scheme="http://blog.xingzheng.top/tags/Framework7/"/>
    
  </entry>
  
  <entry>
    <title>Hexo简明使用</title>
    <link href="http://blog.xingzheng.top/2017/04/21/Hexo-brief-usage.html"/>
    <id>http://blog.xingzheng.top/2017/04/21/Hexo-brief-usage.html</id>
    <published>2017-04-21T23:44:37.000Z</published>
    <updated>2017-04-21T23:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>前提要先安装 node 和 Git，然后使用npm安装Hexo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &lt;layout&gt; &lt;title&gt;</span><br><span class="line">$ hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout 即模板, 可选，如果省略则默认是 <code>post</code>, 即新建文章.<br>存放路径在： <code>source/_posts</code>。</p><a id="more"></a> <h3 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不显示在博客首页，存放路径在 <code>source/_drafts</code>。  </p><h3 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &lt;title&gt;</span><br></pre></td></tr></table></figure><p>如 <code>hexo new page &quot;tags&quot;</code> 新建<code>tags</code>页面，路径在：<code>source/tags</code>。</p><h3 id="修改默认布局"><a href="#修改默认布局" class="headerlink" title="修改默认布局"></a>修改默认布局</h3><p>修改<code>_config.yml</code>中的<code>default_layout</code>配置项，修改为 <code>scaffolds/</code>下的某个布局文件名即可。</p><h3 id="Hexo-Server"><a href="#Hexo-Server" class="headerlink" title="Hexo Server"></a>Hexo Server</h3><p>参考: <a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">Hexo Server</a></p><p>Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure></p><p>安装完成后，输入以下命令以启动服务器，您的网站会在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">或</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><blockquote><p>默认端口4000与Foxit Reader(福昕PDF阅读器）foxitprotect.exe占用端口冲突, 如果启动后无法访问, 请修改端口号.</p></blockquote><ul><li><strong>自定义端口</strong><br><code>hexo server -p 5000</code>  </li><li><strong>静态模式</strong><br><code>hexo server -s</code>, 只处理<code>public</code>文件夹内的文件,不会处理文件变动, 需要先执行<code>hexo generate</code>. 通常用于生产环境下.  </li><li><strong>自定义 IP</strong><br><code>hexo server -i 192.168.1.1</code></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>可选项：<code>-g, --generate</code>，在部署前生成文件.</p><h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><ul><li>调试模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure></li><li>显示草稿<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>例如, <code>hexo server --draft</code> 会启动 Hexo Server 来预览草稿.</li></ul><p>参考：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo概述</a></p><h2 id="Hexo-Next-使用"><a href="#Hexo-Next-使用" class="headerlink" title="Hexo-Next 使用"></a>Hexo-Next 使用</h2><h3 id="创建标签云"><a href="#创建标签云" class="headerlink" title="创建标签云"></a>创建标签云</h3><p><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE%E4%BA%91%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">参考这里</a></p><p>多标签的格式，在 <code>front-master</code> 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tags: [tag1,tag2,tag3]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tags: </span><br><span class="line">    - tag1</span><br><span class="line">    - tag2</span><br><span class="line">    - tag3</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h3><p><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">参考这里</a></p><h3 id="分类-标签数量不准确"><a href="#分类-标签数量不准确" class="headerlink" title="分类/标签数量不准确"></a>分类/标签数量不准确</h3><p>清理并重新生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><h3 id="如何在首页开启“阅读更多”"><a href="#如何在首页开启“阅读更多”" class="headerlink" title="如何在首页开启“阅读更多”"></a>如何在首页开启“阅读更多”</h3><p>在文章中加 <code>&lt;!--more--&gt;</code> 进行截断。</p><h2 id="Travis-自动构建-Hexo"><a href="#Travis-自动构建-Hexo" class="headerlink" title="Travis 自动构建 Hexo"></a>Travis 自动构建 Hexo</h2><p><code>.travis.yml</code>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">"8.11.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">npm@4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">push.default</span> <span class="string">matching</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"songzheng45"</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"songheng45@gmail.com"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">rebuild</span> <span class="string">node-sass</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-feed</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-ejs2</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-stylus</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-marked</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-sass</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-algolia</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">algolia</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">--all</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Travis CI Auto Builder"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--quiet</span> <span class="string">--force</span> <span class="string">https://$GH_Token@github.com/songzheng45/xingzheng.me.git</span> <span class="string">master:gh-pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cache:</span></span><br><span class="line">  <span class="comment">#directories:</span></span><br><span class="line">    <span class="comment">#- node_modules</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Cannot-find-module-‘hexo-util’"><a href="#Cannot-find-module-‘hexo-util’" class="headerlink" title="Cannot find module ‘hexo-util’"></a>Cannot find module ‘hexo-util’</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">ERROR Script load failed: themes/next/scripts/tags/exturl.js</span><br><span class="line">Error: Cannot find module <span class="string">'hexo-util'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">ERROR Script load failed: themes/next/scripts/tags/exturl.js</span><br><span class="line">Error: Cannot find module <span class="string">'hexo-util'</span></span><br></pre></td></tr></table></figure><p>执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-util --save</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Hexo？&quot;&gt;&lt;a href=&quot;#什么是-Hexo？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hexo？&quot;&gt;&lt;/a&gt;什么是 Hexo？&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
&lt;h2 id=&quot;安装Hexo&quot;&gt;&lt;a href=&quot;#安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装Hexo&quot;&gt;&lt;/a&gt;安装Hexo&lt;/h2&gt;&lt;p&gt;前提要先安装 node 和 Git，然后使用npm安装Hexo：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用Hexo&quot;&gt;&lt;a href=&quot;#使用Hexo&quot; class=&quot;headerlink&quot; title=&quot;使用Hexo&quot;&gt;&lt;/a&gt;使用Hexo&lt;/h2&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;新建文章&quot;&gt;&lt;a href=&quot;#新建文章&quot; class=&quot;headerlink&quot; title=&quot;新建文章&quot;&gt;&lt;/a&gt;新建文章&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;lt;layout&amp;gt; &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;layout 即模板, 可选，如果省略则默认是 &lt;code&gt;post&lt;/code&gt;, 即新建文章.&lt;br&gt;存放路径在： &lt;code&gt;source/_posts&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://blog.xingzheng.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Jexus安装使用</title>
    <link href="http://blog.xingzheng.top/2017/04/21/Jexus%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
    <id>http://blog.xingzheng.top/2017/04/21/Jexus%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html</id>
    <published>2017-04-21T23:30:16.000Z</published>
    <updated>2017-04-21T23:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jexus-简介"><a href="#Jexus-简介" class="headerlink" title="Jexus 简介"></a>Jexus 简介</h1><p>Jexus web server for linux 是一款基于mono环境，运行于Linux/unix操作系统之上，以支持ASP.NET为核心功能的高性能WEB服务器。</p><p>独立版Jexus已经继承了mono运行时，不再需要单独安装mono。</p><h1 id="安装-Jexus"><a href="#安装-Jexus" class="headerlink" title="安装 Jexus"></a>安装 Jexus</h1><p>以下是在 Windows 下用 XShell 连接 Ubuntu 的安装过程。</p><a id="more"></a><h2 id="1-下载最新-Jexus-安装包"><a href="#1-下载最新-Jexus-安装包" class="headerlink" title="1. 下载最新 Jexus 安装包"></a>1. 下载最新 Jexus 安装包</h2><p>我下载的最新版是 5.8.2 ，<a href="https://www.linuxdot.net/" target="_blank" rel="noopener">论坛</a> 里“重要下载”版块的”Jexus V5.8.2 64位 Linux 专用版”，压缩包名为”jexus-5.8.2-x64.tar.gz”。</p><h2 id="2-上传到-Ubuntu-并解压"><a href="#2-上传到-Ubuntu-并解压" class="headerlink" title="2. 上传到 Ubuntu 并解压"></a>2. 上传到 Ubuntu 并解压</h2><p>上传到 /usr 目录下，并解压缩，解压缩后的文件夹是 jexus。</p><p>Windows下可以使用 FTP 或 XShell ZMODEM 上传。</p><h2 id="3-启动-Jexus"><a href="#3-启动-Jexus" class="headerlink" title="3. 启动 Jexus"></a>3. 启动 Jexus</h2><p>独立版Jexus不需要另外再安装mono，解压后启动即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;jexus# sudo .&#x2F;jws start</span><br><span class="line">starting... OK</span><br></pre></td></tr></table></figure></p><h2 id="4-参照Jexus-readme文件，创建默认网站"><a href="#4-参照Jexus-readme文件，创建默认网站" class="headerlink" title="4. 参照Jexus readme文件，创建默认网站"></a>4. 参照Jexus readme文件，创建默认网站</h2><p>在 /var/www/default 目录下创建index.html，访问站点即可看到页面。或者访问/info查看Jexus欢迎页面，说明启动成功。</p><h2 id="5-查看-Jexus-运行状态"><a href="#5-查看-Jexus-运行状态" class="headerlink" title="5. 查看 Jexus 运行状态"></a>5. 查看 Jexus 运行状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;jexus$ sudo .&#x2F;jws status</span><br><span class="line">Jexus is running.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Jexus-简介&quot;&gt;&lt;a href=&quot;#Jexus-简介&quot; class=&quot;headerlink&quot; title=&quot;Jexus 简介&quot;&gt;&lt;/a&gt;Jexus 简介&lt;/h1&gt;&lt;p&gt;Jexus web server for linux 是一款基于mono环境，运行于Linux/unix操作系统之上，以支持ASP.NET为核心功能的高性能WEB服务器。&lt;/p&gt;
&lt;p&gt;独立版Jexus已经继承了mono运行时，不再需要单独安装mono。&lt;/p&gt;
&lt;h1 id=&quot;安装-Jexus&quot;&gt;&lt;a href=&quot;#安装-Jexus&quot; class=&quot;headerlink&quot; title=&quot;安装 Jexus&quot;&gt;&lt;/a&gt;安装 Jexus&lt;/h1&gt;&lt;p&gt;以下是在 Windows 下用 XShell 连接 Ubuntu 的安装过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Jexus" scheme="http://blog.xingzheng.top/tags/Jexus/"/>
    
      <category term="mono" scheme="http://blog.xingzheng.top/tags/mono/"/>
    
  </entry>
  
  <entry>
    <title>三个月减脂记录</title>
    <link href="http://blog.xingzheng.top/2017/04/05/%E5%87%8F%E8%84%82%E8%AE%B0%E5%BD%95.html"/>
    <id>http://blog.xingzheng.top/2017/04/05/%E5%87%8F%E8%84%82%E8%AE%B0%E5%BD%95.html</id>
    <published>2017-04-05T12:57:02.000Z</published>
    <updated>2017-05-07T23:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从2月底在朋友圈立了“要在三个月时间内从80kg减到70kg”的flag以来，一直在利用Keep App进行锻炼，选择的是减脂K3课程表。</p><p>到目前为止，一共进行了两个周期（每个周期3周）的减脂课程表。</p><p>身体的变化就是，相同的课程表，做的时候身体感觉越来越轻松，没有那么困难了，Keep也提示“虽然困难但是仍然可以坚持，难度就是合适的”。但是还是觉得没有勇气挑战K4，于是新的周期仍然采用K3.<br>体重的变化是：目前是78kg，仅仅降了2kg。<br>可以说，上一个阶段减脂基本是没效果的，因此这两天在反思，接下来需要做哪些调整。<br>结论就是，之前太不重视饮食了，在饮食上几乎没有做控制。健身达人们都说，“三分靠练，七分靠吃”，但是我一日三餐基本还是像以前那样吃。而我忽视了现在是减脂期，不能像以前那样吃，等过了减脂期后再恢复正常饮食加运动来保持。  </p><blockquote><p>减脂的本质就是其实消耗的总热量大于摄入的总热量，那么翻译过来就是常说的「少吃多动」，只吃不练或只练不吃都必然会在一定程度上削弱效果。</p></blockquote><a id="more"></a><p>那今后就开始真正的控制饮食，现在是一日三餐都在公司食堂、每天就那几样饭菜且无法选择，如何控制饮食呢？这才是问题的重点。让我想一想…..</p><p><strong>饮食计划一</strong><br>根据公司提供的饭菜规律，和之前使用薄荷App进行记录过饭菜的热量，筛选出可以吃的饭菜有：<br>煮玉米，雀巢全脂牛奶，西兰花，牛肉（瘦），芥菜，虾，水果，大白菜……</p><p>杜绝以下食物：<br>烧茄子，红烧肉，红烧狮子头，麻辣鸡块，各种高油食物……</p><hr><p>更新于：2017.04.05（周三）<br>体重：76.5kg。<br>前两周的体重一直停在78kg，挺郁闷的，现在总是有点好兆头了，不过还是要控制饮食。等下周再看效果。</p><hr><p>更新于：2017.04.21（周五）<br>体重：76.5kg。<br>最近饮食上一直有控制，早饭吃好，有什么吃什么。午饭和晚饭主要吃青菜和牛肉（有的话），主食是一勺米饭，晚上不吃主食。不吃辛辣、油腻、油炸的菜。<br>至此已经减肥整整两个月了，已经基本形成锻炼的习惯了，当天如果有Kepp课程安排的话，下班回到家就第一时间先锻炼，反正是要做的，那就第一时间去做。<br>当时订的三个月减肥10kg的大目标，到5月31号截止，努力向着这个目标靠近！</p><hr><p>更新于：2017.05.07（周日）<br>体重：75kg。<br>今天和同事去学游泳了，结果就学了不到2个小时，下午感觉到被晒伤了，胳膊、颈椎、背上火辣辣的。下次得涂上防晒霜，再买件泳衣。不管怎么说迈出了第一步。<br>今晚Keep完去称体重，稳稳的停留在75Kg。想想吹过的牛逼，70Kg的目标，没有尽力而为又怎么可能达成。而且前两周几乎荒废没有练，现在重新开始练感觉好像重新开始似的，又变得有些困难了。逆水行舟，不进则退！<br>最近在看《人类简史》，从一个“间谍卫星一样的高度”去纵观智人的演化史，实在大开眼界。<br>也许以后该多写点文字，不管写的好不好，有没有人看，将输入的东西输出，加深思考，和自己对话。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从2月底在朋友圈立了“要在三个月时间内从80kg减到70kg”的flag以来，一直在利用Keep App进行锻炼，选择的是减脂K3课程表。&lt;/p&gt;
&lt;p&gt;到目前为止，一共进行了两个周期（每个周期3周）的减脂课程表。&lt;/p&gt;
&lt;p&gt;身体的变化就是，相同的课程表，做的时候身体感觉越来越轻松，没有那么困难了，Keep也提示“虽然困难但是仍然可以坚持，难度就是合适的”。但是还是觉得没有勇气挑战K4，于是新的周期仍然采用K3.&lt;br&gt;体重的变化是：目前是78kg，仅仅降了2kg。&lt;br&gt;可以说，上一个阶段减脂基本是没效果的，因此这两天在反思，接下来需要做哪些调整。&lt;br&gt;结论就是，之前太不重视饮食了，在饮食上几乎没有做控制。健身达人们都说，“三分靠练，七分靠吃”，但是我一日三餐基本还是像以前那样吃。而我忽视了现在是减脂期，不能像以前那样吃，等过了减脂期后再恢复正常饮食加运动来保持。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;减脂的本质就是其实消耗的总热量大于摄入的总热量，那么翻译过来就是常说的「少吃多动」，只吃不练或只练不吃都必然会在一定程度上削弱效果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.xingzheng.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="减脂" scheme="http://blog.xingzheng.top/tags/%E5%87%8F%E8%84%82/"/>
    
      <category term="健身" scheme="http://blog.xingzheng.top/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>InnoSetup 使用小结</title>
    <link href="http://blog.xingzheng.top/2017/03/15/InnoSetup%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html"/>
    <id>http://blog.xingzheng.top/2017/03/15/InnoSetup%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html</id>
    <published>2017-03-15T00:21:53.000Z</published>
    <updated>2017-03-15T15:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景<br>接上篇<a href="2017/03/15/Could-not-load-file-or-assembly-System-Version-2-0-5-0-in-NET-4/">Could not load file or assembly System, Version=2.0.5.0 in .NET 4</a>。<br>由于.NET Framework 4.0补丁包，区分 X86、 X64 和 IA64，而客户很难区分自己的电脑是多少位的，因此产品同事希望能在技术上解决。<br>于是查了下 Inno Setup 的相关资料，脚本语言 Pascal。但是毕竟没有深入研究，仅限于这次的需求。 </p></blockquote><p><a href="uploads/InnoSetup中文帮助.pdf">InnoSetup中文帮助.pdf</a></p><h2 id="检查系统是32位还是64位"><a href="#检查系统是32位还是64位" class="headerlink" title="检查系统是32位还是64位"></a>检查系统是32位还是64位</h2><ul><li><p>方法一：<br>检查是64位系统： <code>Check: IsWin64;</code><br>检查是32位系统： <code>Check: &quot;not IsWin64&quot;;</code></p></li><li><p>方法二：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> IsWin64 <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    MsgBox(<span class="string">'must be x64'</span>, mbInformation, MB_OK);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    MsgBox(<span class="string">'x86'</span>, mbInformation, MB_OK);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="判断是否已安装-NET-Framework-4-0"><a href="#判断是否已安装-NET-Framework-4-0" class="headerlink" title="判断是否已安装 .NET Framework 4.0"></a>判断是否已安装 .NET Framework 4.0</h2><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FrameworkIsNotInstalled</span>:</span> Boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  Result :=</span><br><span class="line">    <span class="keyword">not</span> RegKeyExists(</span><br><span class="line">      HKEY_LOCAL_MACHINE, <span class="string">'SOFTWARE\Microsoft\.NETFramework\policy\v4.0'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="根据系统环境安装-NET-Framework-4-以及补丁包"><a href="#根据系统环境安装-NET-Framework-4-以及补丁包" class="headerlink" title="根据系统环境安装 .NET Framework 4 以及补丁包"></a>根据系统环境安装 .NET Framework 4 以及补丁包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[Files]</span><br><span class="line">;如果没有安装 .NET Framework，则将 Microsoft-NET-40.exe 解压到系统临时目录</span><br><span class="line">Source: &quot;C:\DongfangCaiwuSetupFiles\netfx\Microsoft-NET-40.exe&quot;; DestDir: &quot;&#123;tmp&#125;&quot;; Flags: ignoreversion;Check: FrameworkIsNotInstalled;</span><br><span class="line"></span><br><span class="line">; 如果系统是32位，则将32位补丁包解压到系统临时目录</span><br><span class="line">Source: &quot;C:\DongfangCaiwuSetupFiles\netfx\NDP40-KB2468871-v2-x86.exe&quot;; DestDir: &quot;&#123;tmp&#125;&quot;; Flags: ignoreversion;Check: &quot;not IsWin64&quot;;</span><br><span class="line"></span><br><span class="line">; 如果系统是64位，则将64位补丁包解压到系统临时目录</span><br><span class="line">Source: &quot;C:\DongfangCaiwuSetupFiles\netfx\NDP40-KB2468871-v2-x64.exe&quot;; DestDir: &quot;&#123;tmp&#125;&quot;; Flags: ignoreversion;Check: IsWin64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Run]</span><br><span class="line">;如果没有安装 .NET Framework，则运行 Microsoft-NET-40.exe</span><br><span class="line">Filename: &quot;&#123;tmp&#125;\Microsoft-NET-40.exe&quot;; Check: FrameworkIsNotInstalled</span><br><span class="line"></span><br><span class="line">; 如果系统是32位，则运行32位补丁包</span><br><span class="line">Filename: &quot;&#123;tmp&#125;\NDP40-KB2468871-v2-x86.exe&quot;;  Check: &quot;not IsWin64&quot;;</span><br><span class="line"></span><br><span class="line">; 如果系统是64位，则运行64位补丁包</span><br><span class="line">Filename: &quot;&#123;tmp&#125;\NDP40-KB2468871-v2-x64.exe&quot;; Check: IsWin64;</span><br><span class="line"></span><br><span class="line">[Code]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数，判断系统是否已安装 .NET Framework 4.0</span><br><span class="line">function FrameworkIsNotInstalled: Boolean;</span><br><span class="line">begin</span><br><span class="line">  Result :&#x3D;</span><br><span class="line">    not RegKeyExists(</span><br><span class="line">      HKEY_LOCAL_MACHINE, &#39;SOFTWARE\Microsoft\.NETFramework\policy\v4.0&#39;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blogs.msdn.microsoft.com/davidrickard/2015/07/17/installing-net-framework-4-5-automatically-with-inno-setup/" target="_blank" rel="noopener">Installing .NET Framework 4.5 automatically with Inno Setup</a><br><a href="http://www.kynosarges.de/DotNetVersion.html" target="_blank" rel="noopener">Check .NET Version with Inno Setup</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;背景&lt;br&gt;接上篇&lt;a href=&quot;2017/03/15/Could-not-load-file-or-assembly-System-Version-2-0-5-0-in-NET-4/&quot;&gt;Could not load file or assembly System, Version=2.0.5.0 in .NET 4&lt;/a&gt;。&lt;br&gt;由于.NET Framework 4.0补丁包，区分 X86、 X64 和 IA64，而客户很难区分自己的电脑是多少位的，因此产品同事希望能在技术上解决。&lt;br&gt;于是查了下 Inno Setup 的相关资料，脚本语言 Pascal。但是毕竟没有深入研究，仅限于这次的需求。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;uploads/InnoSetup中文帮助.pdf&quot;&gt;InnoSetup中文帮助.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;检查系统是32位还是64位&quot;&gt;&lt;a href=&quot;#检查系统是32位还是64位&quot; class=&quot;headerlink&quot; title=&quot;检查系统是32位还是64位&quot;&gt;&lt;/a&gt;检查系统是32位还是64位&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一：&lt;br&gt;检查是64位系统： &lt;code&gt;Check: IsWin64;&lt;/code&gt;&lt;br&gt;检查是32位系统： &lt;code&gt;Check: &amp;quot;not IsWin64&amp;quot;;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;figure class=&quot;highlight pascal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; IsWin64 &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MsgBox(&lt;span class=&quot;string&quot;&gt;&#39;must be x64&#39;&lt;/span&gt;, mbInformation, MB_OK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MsgBox(&lt;span class=&quot;string&quot;&gt;&#39;x86&#39;&lt;/span&gt;, mbInformation, MB_OK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="InnoSetup" scheme="http://blog.xingzheng.top/tags/InnoSetup/"/>
    
  </entry>
  
  <entry>
    <title>Could not load file or assembly System, Version=2.0.5.0 in .NET 4</title>
    <link href="http://blog.xingzheng.top/2017/03/15/Could-not-load-file-or-assembly-System-Version-2-0-5-0-in-NET-4.html"/>
    <id>http://blog.xingzheng.top/2017/03/15/Could-not-load-file-or-assembly-System-Version-2-0-5-0-in-NET-4.html</id>
    <published>2017-03-15T00:15:05.000Z</published>
    <updated>2017-05-05T20:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：<br>要求使用C#开发一个客户端，然后打包成安装程序给客户使用。<br>初步了解到客户使用的Windows版本（可能还有人在使用XP），选择 .NET Framework 4.0 作为目标框架。  </p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>很快第一个版本测试后上线，不久就反馈回来一个奇怪的问题：<code>Could not load file or assembly System, Version=2.0.5.0</code>。<br>客户环境是 Windows Server 2008，也已安装 .NET Framework 4.0，但是这个报错意思貌似是要去加载<code>System.dll</code>，结果找的却是2.0版本。 奇怪，CLR 应该去加载4.0版本的才对啊！  </p><a id="more"></a><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>首先怀疑是 GAC 的查找方式，但是没有结论，于是打开 Google 。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>通过Google搜索，很快就在 StackOverFlow 上找到一个答复：“确保给.NET Framework 4.0打过补丁”。<br>补丁修复的一个问题是，让便携式类库能够找到正确的运行时（<a href="http://support.microsoft.com/kb/2468871" target="_blank" rel="noopener">KB2468871</a>），在安装 .NET Framework 4.0 补丁包后顺利解决。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该程序使用到识别验证码的一个组件，猜测是由于客户端程序依赖的一个识别验证码的NuGet组件引起的，而我们的开发环境安装的都是最新的 .NET Framework 4.6，所以测试时没有覆盖到这个情况。  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;背景：&lt;br&gt;要求使用C#开发一个客户端，然后打包成安装程序给客户使用。&lt;br&gt;初步了解到客户使用的Windows版本（可能还有人在使用XP），选择 .NET Framework 4.0 作为目标框架。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;很快第一个版本测试后上线，不久就反馈回来一个奇怪的问题：&lt;code&gt;Could not load file or assembly System, Version=2.0.5.0&lt;/code&gt;。&lt;br&gt;客户环境是 Windows Server 2008，也已安装 .NET Framework 4.0，但是这个报错意思貌似是要去加载&lt;code&gt;System.dll&lt;/code&gt;，结果找的却是2.0版本。 奇怪，CLR 应该去加载4.0版本的才对啊！  &lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term=".NET Framework" scheme="http://blog.xingzheng.top/tags/NET-Framework/"/>
    
      <category term="Patch" scheme="http://blog.xingzheng.top/tags/Patch/"/>
    
      <category term="补丁" scheme="http://blog.xingzheng.top/tags/%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages 如何绑定自定义域名</title>
    <link href="http://blog.xingzheng.top/2017/03/12/GitHub-Pages-%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D.html"/>
    <id>http://blog.xingzheng.top/2017/03/12/GitHub-Pages-%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D.html</id>
    <published>2017-03-12T20:22:00.000Z</published>
    <updated>2017-04-21T23:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用-GitHub-添加-CNAME"><a href="#利用-GitHub-添加-CNAME" class="headerlink" title="利用 GitHub 添加 CNAME"></a>利用 GitHub 添加 CNAME</h3><p>进入GitHub仓库，在 <code>Settings</code> 选项卡下找到 <code>GitHub Pages</code>，<code>Source</code> 那里填写 GitHub Pages 所在的分支，然后填写下面的 <code>Custom domain</code>，点击<code>Save</code>。</p><blockquote><p>也可以手动在代码库中提交一个CNAME文件，值就是你的域名。</p></blockquote><h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>在域名解析提供商控制台，添加域名解析，下面以 万网 为例。</p><ol><li>先添加一个CNAME，主机记录写<code>@</code>，后面记录值写上你的 <code>http://username.github.io</code></li><li>再添加一个CNAME，主机记录写 <code>www</code>，后面记录值也是 <code>http://username.github.io</code><br>作用就是，访问你的域名会指向<code>http://username.github.io</code>，然后 GitHub 会根据 GitHub Pages 所在的分支里的 CNAME，返回页面。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;利用-GitHub-添加-CNAME&quot;&gt;&lt;a href=&quot;#利用-GitHub-添加-CNAME&quot; class=&quot;headerlink&quot; title=&quot;利用 GitHub 添加 CNAME&quot;&gt;&lt;/a&gt;利用 GitHub 添加 CNAME&lt;/h3&gt;&lt;p&gt;进入GitH
      
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GitHub Pages" scheme="http://blog.xingzheng.top/tags/GitHub-Pages/"/>
    
      <category term="域名" scheme="http://blog.xingzheng.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Git学习之如何push本地仓库到远程</title>
    <link href="http://blog.xingzheng.top/2017/03/12/Git%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A6%82%E4%BD%95push%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%B0%E8%BF%9C%E7%A8%8B.html"/>
    <id>http://blog.xingzheng.top/2017/03/12/Git%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A6%82%E4%BD%95push%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%B0%E8%BF%9C%E7%A8%8B.html</id>
    <published>2017-03-12T20:07:02.000Z</published>
    <updated>2020-05-31T03:49:26.725Z</updated>
    
    <content type="html"><![CDATA[<p>演示：<br>将一个本地仓库和一个远程仓库关联，并将本地仓库的修改提交到远程仓库。</p><blockquote><p>运行环境：<br>操作系统： Windows<br>远程仓库：Github<br>Git   终端： Git Bash</p></blockquote><h2 id="1-初始化本地仓库"><a href="#1-初始化本地仓库" class="headerlink" title="1. 初始化本地仓库"></a>1. 初始化本地仓库</h2><p>打开 <code>Git Bash</code> ，切换到一个空目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .  </span><br><span class="line">$ git commit -m <span class="string">'初始化'</span></span><br></pre></td></tr></table></figure><br>这三行命令的作用分别是：  </p><ol><li>初始化git仓库</li><li>将所有文件提交到 stage（暂存）</li><li>将 stage 中的更改提交到本地仓库</li></ol><a id="more"></a><h2 id="2-关联远程仓库"><a href="#2-关联远程仓库" class="headerlink" title="2. 关联远程仓库"></a>2. 关联远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关联远程仓库</span></span><br><span class="line">$ git remote add origin &lt;远程仓库地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证远程地址</span></span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>说明：<br>这里的<code>&lt;远程仓库地址&gt;</code>就是你想推送的地址，而且有两种推送方式：<code>HTTPS</code>和<code>SSH</code>。<br>两者的比较：</p><ul><li><code>HTTPS</code>：<br>使用加密的网页访问通道读写仓库，使用用户名和密码进行鉴权。 避免重复输入密码，查看<a href="#">怎样在每次 Push 时不用重复输入密码 </a></li><li><code>SSH</code>：<br>有关什么是 SSH，可参考<a href="http://zh.wikipedia.org/zh/Secure_Shell" target="_blank" rel="noopener">中文维基百科</a>。<br>使用加密通道读写仓库，无单次上传限制，需先设置“<a href="#账户 SSH 公钥">账户 SSH 公钥</a>”，完成配对验证。</li></ul><h2 id="3-推送到-GitHub"><a href="#3-推送到-GitHub" class="headerlink" title="3. 推送到 GitHub"></a>3. 推送到 GitHub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地仓库的更改推送到您指定为源（origin）的远程仓库。</p><hr><p>附录：</p><h2 id="怎样在每次-Push-时不用重复输入密码"><a href="#怎样在每次-Push-时不用重复输入密码" class="headerlink" title="怎样在每次 Push 时不用重复输入密码"></a>怎样在每次 Push 时不用重复输入密码</h2><p>有两种方法：</p><p>使用 SSH 方式进行推送，您需要配置 SSH 公钥后进行操作，详情请阅读 SSH 公钥配置文档。  </p><p>对于 Https 协议: 首先在全局配置保存你的密码， ~/.git-credentials （没有就创建）内添加 <code>https://{username}:{passwd}@git.coding.net</code>。<br>然后执行配置 Git 命令存储认证命令： <code>$git config --global credential.helper store</code>。  </p><p>执行后在 <code>~/.gitconfig</code> 文件会多出下面配置项: <code>credential.helper = store</code></p><p>详情请参考凭证存储 。</p><h2 id="账户-SSH-公钥"><a href="#账户-SSH-公钥" class="headerlink" title="账户 SSH 公钥"></a>账户 SSH 公钥</h2><blockquote><p>账户 SSH 公钥是跟用户账户关联的公钥，一旦设置，SSH 就拥有账户下所有项目仓库的读写权限。 设置“账户 SSH 公钥”是开发者使用 SSH 方式访问/修改代码仓库的“前置工作”，分为“获取 SSH 协议地址”、“生成公钥”、“在 Github 添加公钥”三个步骤。  </p></blockquote><ol><li><p>获取 SSH 协议地址<br>在 Github 仓库主页点击<code>Clone or download</code>下拉框，选择<code>Use SSH</code>，获得 ssh clone 地址，形如：<a href="mailto:`git@github.com">`git@github.com</a>:yourname/repositoryname.git`。</p></li><li><p>生成公钥<br>打开 <code>Git Bash</code>，输入<code>ssh-keygen -t rsa -C &quot;username@example.com&quot;</code>，回车即可（也可以输入密码）：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span>-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br><span class="line"><span class="comment"># Creates a new ssh key, using the provided email as a label</span></span><br><span class="line"><span class="comment"># Generating public/private rsa key pair.</span></span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): [Press enter]  // 推荐使用默认地址,如果使用非默认地址可能需要配置 .ssh/config</span><br></pre></td></tr></table></figure><p>成功之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"user_email@example.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/username/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">'/c/Users/think2/.ssh'</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/username/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/username/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:gGKkPJBzB+7kDe9tyG+7gFDjJP8PrWgjv2YUmYQJwmc user_email@example.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|o....            |</span></span><br><span class="line"><span class="string">|o+oEoo           |</span></span><br><span class="line"><span class="string">|.o=+==o          |</span></span><br><span class="line"><span class="string">| ..+Bo+o         |</span></span><br><span class="line"><span class="string">|  ..**. S        |</span></span><br><span class="line"><span class="string">|   ..+= .        |</span></span><br><span class="line"><span class="string">|    o+o= .       |</span></span><br><span class="line"><span class="string">|   . *=++        |</span></span><br><span class="line"><span class="string">|    ++*=o.       |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;演示：&lt;br&gt;将一个本地仓库和一个远程仓库关联，并将本地仓库的修改提交到远程仓库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行环境：&lt;br&gt;操作系统： Windows&lt;br&gt;远程仓库：Github&lt;br&gt;Git   终端： Git Bash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-初始化本地仓库&quot;&gt;&lt;a href=&quot;#1-初始化本地仓库&quot; class=&quot;headerlink&quot; title=&quot;1. 初始化本地仓库&quot;&gt;&lt;/a&gt;1. 初始化本地仓库&lt;/h2&gt;&lt;p&gt;打开 &lt;code&gt;Git Bash&lt;/code&gt; ，切换到一个空目录：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add .  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &lt;span class=&quot;string&quot;&gt;&#39;初始化&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;这三行命令的作用分别是：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化git仓库&lt;/li&gt;
&lt;li&gt;将所有文件提交到 stage（暂存）&lt;/li&gt;
&lt;li&gt;将 stage 中的更改提交到本地仓库&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://blog.xingzheng.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="http://blog.xingzheng.top/tags/Git/"/>
    
      <category term="版本管理" scheme="http://blog.xingzheng.top/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
